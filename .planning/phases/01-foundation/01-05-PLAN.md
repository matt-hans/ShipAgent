---
phase: 01-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/api/__init__.py
  - src/api/routes/jobs.py
  - src/api/routes/logs.py
  - src/api/schemas.py
  - src/api/main.py
autonomous: true

must_haves:
  truths:
    - "User can create, retrieve, update, and delete jobs via API"
    - "User can list jobs with filters (status, date range, name)"
    - "User can export job logs as plain text"
    - "User can view job history and status"
  artifacts:
    - path: "src/api/routes/jobs.py"
      provides: "Job CRUD endpoints"
      exports: ["router"]
    - path: "src/api/routes/logs.py"
      provides: "Audit log export endpoints"
      exports: ["router"]
    - path: "src/api/schemas.py"
      provides: "Pydantic request/response schemas"
      exports: ["JobCreate", "JobResponse", "JobListResponse"]
    - path: "src/api/main.py"
      provides: "FastAPI application"
      exports: ["app"]
  key_links:
    - from: "src/api/routes/jobs.py"
      to: "src/services/job_service.py"
      via: "uses JobService for business logic"
      pattern: "from src.services.*import.*JobService"
    - from: "src/api/routes/logs.py"
      to: "src/services/audit_service.py"
      via: "uses AuditService for log export"
      pattern: "from src.services.*import.*AuditService"
    - from: "src/api/main.py"
      to: "src/api/routes"
      via: "includes routers"
      pattern: "include_router"
---

<objective>
Create FastAPI endpoints for job management and audit log export, completing the Phase 1 API layer.

Purpose: Expose the job and audit services via REST API for use by the web UI and other clients.

Output: FastAPI application with /jobs and /logs endpoints supporting full CRUD and export.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@src/services/job_service.py
@src/services/audit_service.py
@src/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for API</name>
  <files>
    - src/api/__init__.py
    - src/api/schemas.py
  </files>
  <action>
Create Pydantic models for API request/response validation.

**src/api/__init__.py**:
```python
# API package
```

**src/api/schemas.py**:

1. **Job schemas**:
   ```python
   from datetime import datetime
   from pydantic import BaseModel, Field
   from enum import Enum

   class JobStatusEnum(str, Enum):
       pending = "pending"
       running = "running"
       paused = "paused"
       completed = "completed"
       failed = "failed"
       cancelled = "cancelled"

   class JobModeEnum(str, Enum):
       confirm = "confirm"
       auto = "auto"

   class JobCreate(BaseModel):
       """Request schema for creating a job."""
       name: str = Field(..., min_length=1, max_length=200)
       original_command: str = Field(..., min_length=1)
       description: str | None = Field(None, max_length=500)
       mode: JobModeEnum = JobModeEnum.confirm

   class JobUpdate(BaseModel):
       """Request schema for updating job status."""
       status: JobStatusEnum

   class JobRowResponse(BaseModel):
       """Response schema for a job row."""
       id: str
       row_number: int
       status: str
       row_checksum: str
       tracking_number: str | None
       label_path: str | None
       cost_cents: int | None
       error_code: str | None
       error_message: str | None
       created_at: str
       processed_at: str | None

       class Config:
           from_attributes = True

   class JobResponse(BaseModel):
       """Response schema for a job."""
       id: str
       name: str
       description: str | None
       original_command: str
       status: str
       mode: str

       total_rows: int
       processed_rows: int
       successful_rows: int
       failed_rows: int
       total_cost_cents: int | None

       error_code: str | None
       error_message: str | None

       created_at: str
       started_at: str | None
       completed_at: str | None
       updated_at: str

       class Config:
           from_attributes = True

   class JobSummaryResponse(BaseModel):
       """Response schema for job summary (list view)."""
       id: str
       name: str
       status: str
       mode: str
       total_rows: int
       successful_rows: int
       failed_rows: int
       total_cost_cents: int | None
       created_at: str
       completed_at: str | None

       class Config:
           from_attributes = True

   class JobListResponse(BaseModel):
       """Response schema for paginated job list."""
       jobs: list[JobSummaryResponse]
       total: int
       limit: int
       offset: int
   ```

2. **Audit log schemas**:
   ```python
   class AuditLogResponse(BaseModel):
       """Response schema for an audit log entry."""
       id: str
       job_id: str
       timestamp: str
       level: str
       event_type: str
       message: str
       details: dict | None
       row_number: int | None

       class Config:
           from_attributes = True

   class LogExportResponse(BaseModel):
       """Response schema for log export metadata."""
       job_id: str
       job_name: str
       log_count: int
       filename: str
   ```

3. **Error response schema**:
   ```python
   class ErrorResponse(BaseModel):
       """Standard error response."""
       error_code: str
       message: str
       remediation: str | None = None
       details: dict | None = None
   ```

4. **Filter schemas**:
   ```python
   from datetime import date

   class JobFilters(BaseModel):
       """Query parameters for job list filtering."""
       status: JobStatusEnum | None = None
       name: str | None = None  # Partial match
       created_after: date | None = None
       created_before: date | None = None
   ```
  </action>
  <verify>
    - `python -c "from src.api.schemas import JobCreate, JobResponse, JobListResponse"` succeeds
    - `python -c "from src.api.schemas import JobCreate; j = JobCreate(name='Test', original_command='cmd'); print(j)"` validates
  </verify>
  <done>
    - All Pydantic schemas defined with validation rules
    - Enums for status and mode
    - Config.from_attributes = True for ORM model conversion
    - Error response schema for consistent error handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job routes</name>
  <files>
    - src/api/routes/__init__.py
    - src/api/routes/jobs.py
  </files>
  <action>
Create FastAPI router for job CRUD operations.

**src/api/routes/__init__.py**:
```python
# Routes package
```

**src/api/routes/jobs.py**:

```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from datetime import date

from src.db.connection import get_db
from src.db.models import JobStatus
from src.services import JobService, InvalidStateTransition, AuditService
from src.api.schemas import (
    JobCreate,
    JobUpdate,
    JobResponse,
    JobSummaryResponse,
    JobListResponse,
    JobRowResponse,
    ErrorResponse,
)
from src.errors import ShipAgentError

router = APIRouter(prefix="/jobs", tags=["jobs"])


def get_job_service(db: Session = Depends(get_db)) -> JobService:
    return JobService(db)


def get_audit_service(db: Session = Depends(get_db)) -> AuditService:
    return AuditService(db)


@router.post("", response_model=JobResponse, status_code=201)
def create_job(
    job_data: JobCreate,
    job_svc: JobService = Depends(get_job_service),
    audit_svc: AuditService = Depends(get_audit_service),
):
    """Create a new job."""
    job = job_svc.create_job(
        name=job_data.name,
        original_command=job_data.original_command,
        description=job_data.description,
        mode=job_data.mode.value,
    )
    audit_svc.log_state_change(job.id, "none", "pending")
    return job


@router.get("", response_model=JobListResponse)
def list_jobs(
    status: str | None = Query(None, description="Filter by status"),
    name: str | None = Query(None, description="Filter by name (partial match)"),
    created_after: date | None = Query(None, description="Filter jobs created after date"),
    created_before: date | None = Query(None, description="Filter jobs created before date"),
    limit: int = Query(50, ge=1, le=200),
    offset: int = Query(0, ge=0),
    job_svc: JobService = Depends(get_job_service),
    db: Session = Depends(get_db),
):
    """
    List jobs with optional filters.

    Supports filtering by status, name (partial match), and date range.
    Results are paginated and sorted by created_at DESC.
    """
    # Build query
    from src.db.models import Job

    query = db.query(Job)

    if status:
        query = query.filter(Job.status == JobStatus(status))

    if name:
        query = query.filter(Job.name.ilike(f"%{name}%"))

    if created_after:
        query = query.filter(Job.created_at >= created_after.isoformat())

    if created_before:
        query = query.filter(Job.created_at <= created_before.isoformat() + "T23:59:59")

    # Get total count before pagination
    total = query.count()

    # Apply pagination and ordering
    jobs = (
        query.order_by(Job.created_at.desc())
        .limit(limit)
        .offset(offset)
        .all()
    )

    return JobListResponse(
        jobs=[JobSummaryResponse.model_validate(j) for j in jobs],
        total=total,
        limit=limit,
        offset=offset,
    )


@router.get("/{job_id}", response_model=JobResponse)
def get_job(
    job_id: str,
    job_svc: JobService = Depends(get_job_service),
):
    """Get a job by ID."""
    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    return job


@router.patch("/{job_id}/status", response_model=JobResponse)
def update_job_status(
    job_id: str,
    update: JobUpdate,
    job_svc: JobService = Depends(get_job_service),
    audit_svc: AuditService = Depends(get_audit_service),
):
    """
    Update job status.

    Only valid state transitions are allowed.
    """
    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    old_status = job.status.value

    try:
        job = job_svc.update_status(job_id, JobStatus(update.status.value))
        audit_svc.log_state_change(job_id, old_status, update.status.value)
        return job
    except InvalidStateTransition as e:
        raise HTTPException(
            status_code=400,
            detail=f"Invalid state transition: {old_status} -> {update.status.value}",
        )


@router.delete("/{job_id}", status_code=204)
def delete_job(
    job_id: str,
    job_svc: JobService = Depends(get_job_service),
):
    """Delete a job and all associated data."""
    if not job_svc.delete_job(job_id):
        raise HTTPException(status_code=404, detail="Job not found")
    return None


@router.get("/{job_id}/rows", response_model=list[JobRowResponse])
def get_job_rows(
    job_id: str,
    status: str | None = Query(None, description="Filter by row status"),
    job_svc: JobService = Depends(get_job_service),
):
    """Get all rows for a job, optionally filtered by status."""
    from src.db.models import RowStatus

    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    row_status = RowStatus(status) if status else None
    rows = job_svc.get_rows(job_id, status=row_status)
    return rows


@router.get("/{job_id}/summary")
def get_job_summary(
    job_id: str,
    job_svc: JobService = Depends(get_job_service),
):
    """Get job summary with aggregated metrics."""
    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    return job_svc.get_job_summary(job_id)
```
  </action>
  <verify>
    - `python -c "from src.api.routes.jobs import router; print(router.routes)"` shows routes
  </verify>
  <done>
    - POST /jobs creates job
    - GET /jobs lists with filters and pagination
    - GET /jobs/{id} retrieves single job
    - PATCH /jobs/{id}/status updates status with validation
    - DELETE /jobs/{id} removes job
    - GET /jobs/{id}/rows lists rows with optional status filter
    - GET /jobs/{id}/summary returns aggregated metrics
    - State changes logged to audit
  </done>
</task>

<task type="auto">
  <name>Task 3: Create log routes and main app</name>
  <files>
    - src/api/routes/logs.py
    - src/api/main.py
  </files>
  <action>
Create audit log routes and main FastAPI application.

**src/api/routes/logs.py**:

```python
from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import PlainTextResponse
from sqlalchemy.orm import Session

from src.db.connection import get_db
from src.db.models import LogLevel, EventType
from src.services import AuditService
from src.api.schemas import AuditLogResponse, LogExportResponse

router = APIRouter(prefix="/jobs/{job_id}/logs", tags=["logs"])


def get_audit_service(db: Session = Depends(get_db)) -> AuditService:
    return AuditService(db)


@router.get("", response_model=list[AuditLogResponse])
def get_job_logs(
    job_id: str,
    level: str | None = Query(None, description="Filter by log level"),
    event_type: str | None = Query(None, description="Filter by event type"),
    limit: int = Query(1000, ge=1, le=10000),
    audit_svc: AuditService = Depends(get_audit_service),
):
    """
    Get audit logs for a job.

    Supports filtering by level (INFO, WARNING, ERROR) and event type.
    """
    from src.services import JobService
    from src.db.connection import get_db

    # Verify job exists
    db = next(get_db())
    job_svc = JobService(db)
    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    log_level = LogLevel(level) if level else None
    log_event_type = EventType(event_type) if event_type else None

    logs = audit_svc.get_logs(
        job_id,
        level=log_level,
        event_type=log_event_type,
        limit=limit,
    )
    return logs


@router.get("/errors", response_model=list[AuditLogResponse])
def get_job_errors(
    job_id: str,
    limit: int = Query(10, ge=1, le=100),
    audit_svc: AuditService = Depends(get_audit_service),
):
    """Get recent error logs for a job."""
    from src.services import JobService
    from src.db.connection import get_db

    db = next(get_db())
    job_svc = JobService(db)
    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    return audit_svc.get_recent_errors(job_id, limit=limit)


@router.get("/export", response_class=PlainTextResponse)
def export_job_logs(
    job_id: str,
    audit_svc: AuditService = Depends(get_audit_service),
):
    """
    Export all logs for a job as plain text.

    Returns a downloadable text file with formatted log entries.
    Sensitive data is redacted.
    """
    from src.services import JobService
    from src.db.connection import get_db

    db = next(get_db())
    job_svc = JobService(db)
    job = job_svc.get_job(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")

    filename, content = audit_svc.export_logs_for_download(job_id, job.name)

    return PlainTextResponse(
        content=content,
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )
```

**src/api/main.py**:

```python
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from src.db.connection import init_db
from src.api.routes import jobs, logs
from src.errors import ShipAgentError

# Create FastAPI app
app = FastAPI(
    title="ShipAgent API",
    description="Natural language interface for batch shipment processing",
    version="0.1.0",
)

# CORS middleware for development
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.on_event("startup")
def startup_event():
    """Initialize database on startup."""
    init_db()


@app.exception_handler(ShipAgentError)
async def shipagent_error_handler(request: Request, exc: ShipAgentError):
    """Handle ShipAgentError exceptions with consistent format."""
    return JSONResponse(
        status_code=400,
        content={
            "error_code": exc.code,
            "message": exc.message,
            "remediation": exc.remediation,
            "details": exc.details if exc.details else None,
        },
    )


# Include routers
app.include_router(jobs.router, prefix="/api/v1")
app.include_router(logs.router, prefix="/api/v1")


@app.get("/health")
def health_check():
    """Health check endpoint."""
    return {"status": "healthy"}


@app.get("/")
def root():
    """API root with links to docs."""
    return {
        "name": "ShipAgent API",
        "version": "0.1.0",
        "docs": "/docs",
        "redoc": "/redoc",
    }
```
  </action>
  <verify>
    - `python -c "from src.api.main import app; print([r.path for r in app.routes])"` shows all routes
    - `uvicorn src.api.main:app --host 0.0.0.0 --port 8000` starts server (test then kill)
  </verify>
  <done>
    - GET /api/v1/jobs/{id}/logs returns job logs with filters
    - GET /api/v1/jobs/{id}/logs/errors returns recent errors
    - GET /api/v1/jobs/{id}/logs/export downloads plain text logs
    - FastAPI app configured with CORS and error handling
    - Health check endpoint at /health
    - API docs at /docs
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run this integration test:

```bash
# Start server in background
python -c "from src.api.main import app; import uvicorn; uvicorn.run(app, host='127.0.0.1', port=8765)" &
SERVER_PID=$!
sleep 2

# Test API endpoints
echo "Testing ShipAgent API..."

# Health check
echo "1. Health check:"
curl -s http://127.0.0.1:8765/health | python -m json.tool

# Create a job
echo -e "\n2. Create job:"
JOB=$(curl -s -X POST http://127.0.0.1:8765/api/v1/jobs \
  -H "Content-Type: application/json" \
  -d '{"name": "Test Batch", "original_command": "Ship California orders via Ground"}')
echo $JOB | python -m json.tool
JOB_ID=$(echo $JOB | python -c "import sys, json; print(json.load(sys.stdin)['id'])")
echo "Job ID: $JOB_ID"

# Get job
echo -e "\n3. Get job:"
curl -s http://127.0.0.1:8765/api/v1/jobs/$JOB_ID | python -m json.tool

# Update status
echo -e "\n4. Update status to running:"
curl -s -X PATCH http://127.0.0.1:8765/api/v1/jobs/$JOB_ID/status \
  -H "Content-Type: application/json" \
  -d '{"status": "running"}' | python -m json.tool

# Try invalid transition (should fail)
echo -e "\n5. Try invalid transition (running -> pending):"
curl -s -X PATCH http://127.0.0.1:8765/api/v1/jobs/$JOB_ID/status \
  -H "Content-Type: application/json" \
  -d '{"status": "pending"}'

# List jobs
echo -e "\n6. List jobs:"
curl -s "http://127.0.0.1:8765/api/v1/jobs?limit=5" | python -m json.tool

# Get logs
echo -e "\n7. Get job logs:"
curl -s http://127.0.0.1:8765/api/v1/jobs/$JOB_ID/logs | python -m json.tool

# Export logs
echo -e "\n8. Export logs (first 200 chars):"
curl -s http://127.0.0.1:8765/api/v1/jobs/$JOB_ID/logs/export | head -c 200
echo "..."

# Get summary
echo -e "\n9. Get job summary:"
curl -s http://127.0.0.1:8765/api/v1/jobs/$JOB_ID/summary | python -m json.tool

# Delete job
echo -e "\n10. Delete job:"
curl -s -X DELETE http://127.0.0.1:8765/api/v1/jobs/$JOB_ID -w "%{http_code}\n"

# Stop server
kill $SERVER_PID 2>/dev/null

# Cleanup
rm -f shipagent.db

echo -e "\nAll API tests passed!"
```
</verification>

<success_criteria>
1. FastAPI server starts and serves at /docs
2. POST /api/v1/jobs creates a job and returns 201
3. GET /api/v1/jobs lists jobs with pagination and filters
4. GET /api/v1/jobs/{id} returns single job
5. PATCH /api/v1/jobs/{id}/status validates transitions
6. DELETE /api/v1/jobs/{id} removes job
7. GET /api/v1/jobs/{id}/logs returns logs with filters
8. GET /api/v1/jobs/{id}/logs/export returns downloadable text
9. ShipAgentError exceptions return consistent error format
10. Health check at /health returns status
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
