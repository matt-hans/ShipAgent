---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/audit_service.py
  - src/services/__init__.py
autonomous: true

must_haves:
  truths:
    - "Every operation writes timestamped log entries"
    - "Logs are scoped to specific jobs"
    - "Sensitive data is redacted in log entries"
    - "Logs can be exported as plain text"
  artifacts:
    - path: "src/services/audit_service.py"
      provides: "Audit logging service"
      exports: ["AuditService", "LogLevel", "EventType"]
  key_links:
    - from: "src/services/audit_service.py"
      to: "src/db/models.py"
      via: "imports AuditLog model"
      pattern: "from src.db.*import.*AuditLog"
    - from: "src/services/audit_service.py"
      to: "src/db/connection.py"
      via: "uses Session for database operations"
      pattern: "Session"
---

<objective>
Create the Audit Service for job-scoped logging with sensitive data redaction and plain text export.

Purpose: Provide full audit trail of all operations for debugging and compliance, with redaction of personally identifiable information.

Output: AuditService class that logs events to the database with automatic redaction and supports text export.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@src/db/models.py
@src/db/connection.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AuditService with logging methods</name>
  <files>
    - src/services/audit_service.py
  </files>
  <action>
Create the audit service with logging methods and redaction.

**src/services/audit_service.py**:

1. **Re-export enums** from models for convenience:
   ```python
   from src.db.models import LogLevel, EventType
   ```

2. **Redaction configuration**:
   ```python
   # Fields to redact in log details
   REDACT_FIELDS = {
       # Address fields
       'address', 'address1', 'address2', 'address_line_1', 'address_line_2',
       'street', 'city', 'state', 'postal_code', 'zip', 'zip_code', 'country',
       # Personal info
       'name', 'first_name', 'last_name', 'phone', 'email', 'company',
       'shipper_name', 'recipient_name', 'ship_to', 'ship_from',
       # Account info
       'account_number', 'shipper_number', 'access_token', 'refresh_token',
       'client_id', 'client_secret', 'api_key',
   }

   REDACTED = '[REDACTED]'
   ```

3. **Redaction function**:
   ```python
   def redact_sensitive(data: dict | list | str | None, _depth: int = 0) -> dict | list | str | None:
       """Recursively redact sensitive fields from data structures."""
       if _depth > 10:  # Prevent infinite recursion
           return REDACTED
       if data is None:
           return None
       if isinstance(data, str):
           return data
       if isinstance(data, list):
           return [redact_sensitive(item, _depth + 1) for item in data]
       if isinstance(data, dict):
           result = {}
           for key, value in data.items():
               key_lower = key.lower().replace('-', '_')
               if any(field in key_lower for field in REDACT_FIELDS):
                   result[key] = REDACTED
               else:
                   result[key] = redact_sensitive(value, _depth + 1)
           return result
       return data  # For other types, return as-is
   ```

4. **AuditService class**:

   Constructor:
   - `__init__(self, db: Session)`: Accept SQLAlchemy session

   Core logging method:
   - `log(job_id: str, level: LogLevel, event_type: EventType, message: str, details: dict | None = None, row_number: int | None = None) -> AuditLog`:
     - Create AuditLog entry
     - If details provided, redact sensitive data and store as JSON string
     - Set timestamp to current UTC ISO8601
     - Add, commit, return

   Convenience methods:
   - `log_info(job_id: str, event_type: EventType, message: str, **kwargs)`:
     - Shorthand for log with level=INFO

   - `log_warning(job_id: str, event_type: EventType, message: str, **kwargs)`:
     - Shorthand for log with level=WARNING

   - `log_error(job_id: str, event_type: EventType, message: str, **kwargs)`:
     - Shorthand for log with level=ERROR

   Event-specific methods:
   - `log_state_change(job_id: str, old_state: str, new_state: str)`:
     - Log state_change event with INFO level
     - Message: f"Job state changed: {old_state} -> {new_state}"

   - `log_api_call(job_id: str, endpoint: str, method: str, request: dict | None, response: dict | None, status_code: int, row_number: int | None = None)`:
     - Log api_call event
     - Level: INFO if status_code < 400, WARNING if 400-499, ERROR if 500+
     - Details contain redacted request and response

   - `log_row_event(job_id: str, row_number: int, event: str, details: dict | None = None)`:
     - Log row_event for row processing milestones
     - Events: "started", "completed", "failed", "skipped"
     - Level: INFO for started/completed/skipped, ERROR for failed

   - `log_job_error(job_id: str, error_code: str, error_message: str, details: dict | None = None)`:
     - Log error event for job-level errors
     - Level: ERROR
  </action>
  <verify>
    - `python -c "from src.services.audit_service import AuditService, redact_sensitive, LogLevel, EventType"` succeeds
    - `python -c "from src.services.audit_service import redact_sensitive; print(redact_sensitive({'name': 'John', 'amount': 100}))"` shows redacted name
  </verify>
  <done>
    - AuditService class implemented with all logging methods
    - Sensitive data redacted before storage
    - Convenience methods for common event types
    - Enums re-exported for easy import
  </done>
</task>

<task type="auto">
  <name>Task 2: Add log query and export methods</name>
  <files>
    - src/services/audit_service.py
    - src/services/__init__.py
  </files>
  <action>
Add methods for querying and exporting audit logs.

**Add to AuditService class**:

Query methods:
- `get_logs(job_id: str, level: LogLevel | None = None, event_type: EventType | None = None, limit: int = 1000) -> list[AuditLog]`:
  - Get logs for job with optional filters
  - Order by timestamp ASC (chronological)
  - Apply limit

- `get_recent_errors(job_id: str, limit: int = 10) -> list[AuditLog]`:
  - Get most recent ERROR level logs for job
  - Order by timestamp DESC

Export methods:
- `export_logs_text(job_id: str) -> str`:
  - Export all logs for job as plain text
  - Format each entry as:
    ```
    [2024-01-23T10:30:45Z] [INFO] [state_change] Job state changed: pending -> running
    [2024-01-23T10:30:46Z] [INFO] [api_call] UPS Rating API called
        Request: {"service": "03", "package": {...}}
        Response: {"total": "12.50", ...}
        Status: 200
    [2024-01-23T10:30:47Z] [ERROR] [row_event] Row 5 failed
        Details: {"error_code": "E-2001", "message": "Invalid ZIP"}
    ```
  - Include row_number in output if present: `[Row 5]` prefix
  - Pretty-print JSON details with 4-space indent

- `export_logs_for_download(job_id: str, job_name: str) -> tuple[str, str]`:
  - Returns (filename, content) for download
  - Filename format: `{job_name}_logs_{timestamp}.txt`
  - Clean job_name for filesystem (replace spaces with underscores, remove special chars)

**Update src/services/__init__.py**:
```python
from src.services.job_service import JobService, InvalidStateTransition
from src.services.audit_service import AuditService, redact_sensitive, LogLevel, EventType

__all__ = [
    "JobService",
    "InvalidStateTransition",
    "AuditService",
    "redact_sensitive",
    "LogLevel",
    "EventType",
]
```
  </action>
  <verify>
    - Run integration test (see verification section)
  </verify>
  <done>
    - Log query methods work with filters
    - Plain text export formats logs readably
    - Export includes all details, redacted
    - Services __init__ exports all public API
  </done>
</task>

</tasks>

<verification>
After all tasks complete, run this integration test:

```bash
python -c "
from src.db.connection import init_db, get_db
from src.db.models import JobStatus
from src.services import JobService, AuditService, LogLevel, EventType, redact_sensitive

# Setup
init_db()
db = next(get_db())
job_svc = JobService(db)
audit_svc = AuditService(db)

# Create a job
job = job_svc.create_job('Test Audit', 'Ship test orders')
print(f'1. Created job: {job.id}')

# Log state change
audit_svc.log_state_change(job.id, 'pending', 'running')
print('2. Logged state change')

# Log API call with sensitive data
audit_svc.log_api_call(
    job.id,
    endpoint='/v1/shipments',
    method='POST',
    request={
        'shipper': {'name': 'Acme Corp', 'address': '123 Main St'},
        'recipient': {'name': 'John Doe', 'email': 'john@example.com'},
        'package': {'weight': 5.0}
    },
    response={'tracking_number': 'TRACK001', 'cost': '12.50'},
    status_code=200,
    row_number=1
)
print('3. Logged API call with redacted sensitive data')

# Log row events
audit_svc.log_row_event(job.id, 1, 'completed', {'tracking': 'TRACK001'})
audit_svc.log_row_event(job.id, 2, 'failed', {'error_code': 'E-2001', 'message': 'Bad ZIP'})
print('4. Logged row events')

# Log error
audit_svc.log_job_error(job.id, 'E-3001', 'UPS API timeout', {'endpoint': '/v1/shipments'})
print('5. Logged job error')

# Test redaction
test_data = {
    'recipient_name': 'John Doe',
    'address_line_1': '123 Main St',
    'amount': 100,
    'nested': {'phone': '555-1234', 'value': 50}
}
redacted = redact_sensitive(test_data)
print(f'6. Redaction test:')
print(f'   Original: {test_data}')
print(f'   Redacted: {redacted}')
assert redacted['recipient_name'] == '[REDACTED]'
assert redacted['amount'] == 100  # Not redacted

# Query logs
logs = audit_svc.get_logs(job.id)
print(f'7. Found {len(logs)} log entries')

errors = audit_svc.get_recent_errors(job.id)
print(f'8. Found {len(errors)} error entries')

# Export
export = audit_svc.export_logs_text(job.id)
print('9. Exported logs (first 500 chars):')
print(export[:500])
print('...')

# Verify sensitive data is redacted in export
assert 'John Doe' not in export  # Name should be redacted
assert '[REDACTED]' in export  # Redaction placeholder present
print('10. Verified sensitive data redacted in export')

# Cleanup
job_svc.delete_job(job.id)
db.close()
print('\\nAll tests passed!')
"

# Cleanup test database
rm -f shipagent.db
```
</verification>

<success_criteria>
1. AuditService logs events to database with timestamps
2. Sensitive data (names, addresses, account numbers) automatically redacted
3. Convenience methods exist for common event types
4. Logs can be queried with filters
5. Plain text export produces human-readable output
6. Redaction works recursively on nested structures
7. Export includes job/row context for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
