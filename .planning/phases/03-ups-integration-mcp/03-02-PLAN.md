---
phase: 03-ups-integration-mcp
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/ups-mcp/src/auth/manager.ts
  - packages/ups-mcp/src/client/api.ts
  - packages/ups-mcp/src/client/errors.ts
  - packages/ups-mcp/tests/auth.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "OAuth token is obtained from UPS sandbox endpoint"
    - "Token is cached and reused until near expiry"
    - "Token refresh happens automatically with 1-minute buffer"
    - "Failed token refresh clears cache and throws auth error"
    - "HTTP requests retry on 5xx errors with exponential backoff"
    - "HTTP requests fail immediately on 4xx errors"
  artifacts:
    - path: "packages/ups-mcp/src/auth/manager.ts"
      provides: "OAuth token acquisition and caching"
      exports: ["UpsAuthManager"]
    - path: "packages/ups-mcp/src/client/api.ts"
      provides: "HTTP client with retry logic"
      exports: ["UpsApiClient"]
    - path: "packages/ups-mcp/src/client/errors.ts"
      provides: "Error types for auth and API failures"
      exports: ["UpsAuthError", "UpsApiError"]
    - path: "packages/ups-mcp/tests/auth.test.ts"
      provides: "Unit tests for auth manager"
      contains: "describe"
  key_links:
    - from: "packages/ups-mcp/src/client/api.ts"
      to: "packages/ups-mcp/src/auth/manager.ts"
      via: "authManager.getToken()"
      pattern: "authManager\\.getToken"
    - from: "packages/ups-mcp/src/client/api.ts"
      to: "packages/ups-mcp/src/client/errors.ts"
      via: "throw UpsApiError"
      pattern: "throw new UpsApiError"
---

<objective>
Implement OAuth 2.0 authentication and HTTP client with retry logic for UPS API communication.

Purpose: Provide reliable, authenticated access to UPS APIs with automatic token refresh and resilient error handling. This is the foundation layer that all MCP tools use to communicate with UPS.

Output: UpsAuthManager class managing OAuth tokens, UpsApiClient class with retry logic, and comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ups-integration-mcp/03-RESEARCH.md
@.planning/phases/03-ups-integration-mcp/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error types</name>
  <files>
    packages/ups-mcp/src/client/errors.ts
  </files>
  <action>
    Create typed error classes for auth and API failures:

    1. Create src/client/errors.ts with:

    UpsAuthError class:
    - Extends Error
    - Properties: message, cause (optional)
    - Constructor: (message: string, cause?: Error)
    - Name: "UpsAuthError"

    UpsApiError class:
    - Extends Error
    - Properties: statusCode, errorCode, errorMessage, field (all from UPS response)
    - Constructor: (response: UpsErrorResponse)
    - Name: "UpsApiError"
    - Parse UPS error response format which includes:
      - response.errors[0].code
      - response.errors[0].message
      - response.errors[0].context (optional field path)

    UpsNetworkError class:
    - Extends Error
    - Properties: cause
    - Constructor: (message: string, cause?: Error)
    - Name: "UpsNetworkError"

    Per CONTEXT.md Decision 4: Return UPS error codes as-is (no translation at MCP layer).
  </action>
  <verify>
    cd packages/ups-mcp && pnpm run build
    grep "UpsAuthError" packages/ups-mcp/src/client/errors.ts
    grep "UpsApiError" packages/ups-mcp/src/client/errors.ts
  </verify>
  <done>
    Error types exist for auth failures, API errors, and network errors with proper typing
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OAuth token manager</name>
  <files>
    packages/ups-mcp/src/auth/manager.ts
    packages/ups-mcp/tests/auth.test.ts
  </files>
  <action>
    Create UpsAuthManager class for OAuth 2.0 client_credentials flow:

    1. Create src/auth/manager.ts:

    ```typescript
    export class UpsAuthManager {
      private token: string | null = null;
      private expiresAt: number = 0;

      constructor(
        private clientId: string,
        private clientSecret: string,
        private tokenUrl = 'https://wwwcie.ups.com/security/v1/oauth/token'
      ) {}

      async getToken(): Promise<string> {
        // Return cached token if valid (with 60-second buffer before expiry)
        if (this.token && Date.now() < this.expiresAt - 60000) {
          return this.token;
        }
        return this.refreshToken();
      }

      private async refreshToken(): Promise<string> {
        // POST to token endpoint with Basic auth
        // Header: Authorization: Basic base64(clientId:clientSecret)
        // Body: grant_type=client_credentials
        // Parse response: { access_token, expires_in }
        // Cache token and compute expiresAt
        // On failure: clear token, throw UpsAuthError
      }

      clearToken(): void {
        this.token = null;
        this.expiresAt = 0;
      }
    }
    ```

    Per CONTEXT.md Decision 4:
    - On auth failure, clear token immediately
    - Return specific authentication error

    2. Create tests/auth.test.ts with vitest:
    - Test: getToken returns cached token when valid
    - Test: getToken refreshes when token expired
    - Test: getToken refreshes when within 60s of expiry
    - Test: refreshToken throws UpsAuthError on 401
    - Test: clearToken removes cached token

    Use vitest mocking for fetch.
  </action>
  <verify>
    cd packages/ups-mcp && pnpm run build
    cd packages/ups-mcp && pnpm test -- auth.test.ts
  </verify>
  <done>
    OAuth manager acquires and caches tokens, refreshes before expiry, handles failures properly
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement HTTP client with retry</name>
  <files>
    packages/ups-mcp/src/client/api.ts
  </files>
  <action>
    Create UpsApiClient class with retry logic:

    1. Create src/client/api.ts:

    ```typescript
    export class UpsApiClient {
      constructor(
        private authManager: UpsAuthManager,
        private baseUrl = 'https://wwwcie.ups.com/api'
      ) {}

      async request<T>(
        method: string,
        path: string,
        body?: unknown
      ): Promise<T> {
        const token = await this.authManager.getToken();

        const response = await this.fetchWithRetry(
          `${this.baseUrl}${path}`,
          {
            method,
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json',
              'transId': crypto.randomUUID(),
              'transactionSrc': 'shipagent'
            },
            body: body ? JSON.stringify(body) : undefined
          }
        );

        if (!response.ok) {
          const error = await response.json();
          throw new UpsApiError(error);
        }

        return response.json();
      }

      private async fetchWithRetry(
        url: string,
        options: RequestInit,
        maxRetries = 3
      ): Promise<Response> {
        const delays = [1000, 2000, 4000]; // Exponential backoff

        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          try {
            const response = await fetch(url, options);

            // Don't retry 4xx client errors
            if (response.status >= 400 && response.status < 500) {
              return response;
            }

            // Retry 5xx server errors
            if (response.status >= 500 && attempt < maxRetries) {
              await this.sleep(delays[attempt]);
              continue;
            }

            return response;
          } catch (error) {
            // Network error - retry
            if (attempt < maxRetries) {
              await this.sleep(delays[attempt]);
              continue;
            }
            throw new UpsNetworkError('Network request failed', error);
          }
        }

        throw new UpsNetworkError('Max retries exceeded');
      }

      private sleep(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
      }
    }
    ```

    Per CONTEXT.md Decision 4:
    - Retry on 5xx and network errors only
    - Fail immediately on 4xx
    - Max 3 attempts with 1s/2s/4s backoff
    - Include transId and transactionSrc headers
  </action>
  <verify>
    cd packages/ups-mcp && pnpm run build
    grep "fetchWithRetry" packages/ups-mcp/src/client/api.ts
    grep "transId" packages/ups-mcp/src/client/api.ts
  </verify>
  <done>
    HTTP client retries 5xx/network errors with exponential backoff, fails fast on 4xx
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
# Error types exist
grep "export class UpsAuthError" packages/ups-mcp/src/client/errors.ts
grep "export class UpsApiError" packages/ups-mcp/src/client/errors.ts

# Auth manager implemented
grep "class UpsAuthManager" packages/ups-mcp/src/auth/manager.ts
grep "getToken" packages/ups-mcp/src/auth/manager.ts
grep "refreshToken" packages/ups-mcp/src/auth/manager.ts
grep "clearToken" packages/ups-mcp/src/auth/manager.ts

# API client implemented
grep "class UpsApiClient" packages/ups-mcp/src/client/api.ts
grep "fetchWithRetry" packages/ups-mcp/src/client/api.ts

# TypeScript compiles
cd packages/ups-mcp && pnpm run build

# Tests pass
cd packages/ups-mcp && pnpm test
```
</verification>

<success_criteria>
- UpsAuthManager acquires OAuth tokens from UPS sandbox endpoint
- Tokens are cached and reused until 60 seconds before expiry
- Auth failures clear token cache and throw UpsAuthError
- UpsApiClient includes transId and transactionSrc headers
- 5xx errors retry with 1s/2s/4s exponential backoff
- 4xx errors fail immediately without retry
- Network errors retry then throw UpsNetworkError
- Unit tests pass for auth manager
</success_criteria>

<output>
After completion, create `.planning/phases/03-ups-integration-mcp/03-02-SUMMARY.md`
</output>
