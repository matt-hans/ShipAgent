---
phase: 03-ups-integration-mcp
plan: 05
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - packages/ups-mcp/src/tools/address.ts
  - packages/ups-mcp/src/index.ts
  - packages/ups-mcp/tests/address.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can validate an address with UPS"
    - "Valid addresses return cleaned/standardized format"
    - "Ambiguous addresses return candidate suggestions"
    - "Invalid addresses return clear reason why"
  artifacts:
    - path: "packages/ups-mcp/src/tools/address.ts"
      provides: "Address validation tool implementation"
      exports: ["registerAddressTools"]
    - path: "packages/ups-mcp/tests/address.test.ts"
      provides: "Unit tests for address tool"
      contains: "address_validate"
  key_links:
    - from: "packages/ups-mcp/src/index.ts"
      to: "packages/ups-mcp/src/tools/address.ts"
      via: "registerAddressTools(server)"
      pattern: "registerAddressTools"
---

<objective>
Implement address_validate MCP tool for UPS address validation.

Purpose: Enable users to verify addresses before creating shipments. This is a separate tool per CONTEXT.md decision - shipping_create does NOT auto-validate. Users compose validation into their workflow as needed.

Output: Registered MCP tool that validates addresses with UPS and returns standardized format, candidates, or errors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ups-integration-mcp/03-RESEARCH.md
@.planning/phases/03-ups-integration-mcp/03-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create address validation tool</name>
  <files>
    packages/ups-mcp/src/tools/address.ts
  </files>
  <action>
    Create address validation tool module:

    1. Create src/tools/address.ts:

    Define input schema:
    ```typescript
    const AddressValidationInputSchema = z.object({
      addressLine1: z.string().describe('Street address line 1'),
      addressLine2: z.string().optional().describe('Street address line 2'),
      city: z.string().describe('City name'),
      stateProvinceCode: z.string().describe('State/province code (e.g., CA, NY)'),
      postalCode: z.string().describe('Postal/ZIP code'),
      countryCode: z.string().default('US').describe('Country code')
    });
    ```

    Define output schema:
    ```typescript
    const AddressValidationOutputSchema = z.object({
      status: z.enum(['valid', 'ambiguous', 'invalid']),
      classification: z.enum(['commercial', 'residential', 'unknown']).optional(),
      validatedAddress: z.object({
        addressLine1: z.string(),
        addressLine2: z.string().optional(),
        city: z.string(),
        stateProvinceCode: z.string(),
        postalCode: z.string(),
        countryCode: z.string()
      }).optional(),
      candidates: z.array(z.object({
        addressLine1: z.string(),
        addressLine2: z.string().optional(),
        city: z.string(),
        stateProvinceCode: z.string(),
        postalCode: z.string(),
        countryCode: z.string(),
        classification: z.enum(['commercial', 'residential', 'unknown']).optional()
      })).optional(),
      invalidReason: z.string().optional()
    });
    ```

    2. Implement address_validate tool:
    - POST to /addressvalidation/v2/1
    - Build UPS AddressValidationRequest structure
    - Parse response to determine status:
      - Valid: single exact match → status: 'valid'
      - Ambiguous: multiple candidates → status: 'ambiguous' with candidates array
      - Invalid: no valid match → status: 'invalid' with reason
    - Extract classification (commercial vs residential) from UPS response

    UPS Address Validation response structure:
    ```json
    {
      "XAVResponse": {
        "ValidAddressIndicator": "present if valid",
        "AmbiguousAddressIndicator": "present if ambiguous",
        "NoCandidatesIndicator": "present if no matches",
        "Candidate": [{
          "AddressClassification": { "Code": "1" }, // 1=commercial, 2=residential
          "AddressLine": ["123 MAIN ST"],
          "PoliticalDivision2": "CITY",
          "PoliticalDivision1": "ST",
          "PostcodePrimaryLow": "12345",
          "CountryCode": "US"
        }]
      }
    }
    ```

    3. Export registerAddressTools(server, apiClient) function
  </action>
  <verify>
    cd packages/ups-mcp && pnpm run build
    grep "address_validate" packages/ups-mcp/src/tools/address.ts
    grep "registerAddressTools" packages/ups-mcp/src/tools/address.ts
  </verify>
  <done>
    Address validation tool implemented with status/candidates/reason output
  </done>
</task>

<task type="auto">
  <name>Task 2: Register address tool and add tests</name>
  <files>
    packages/ups-mcp/src/index.ts
    packages/ups-mcp/tests/address.test.ts
  </files>
  <action>
    1. Update src/index.ts to register address tools:
    ```typescript
    import { registerAddressTools } from './tools/address.js';

    // After creating server and apiClient:
    registerAddressTools(server, apiClient);
    ```

    2. Create tests/address.test.ts:
    - Test: valid address returns status 'valid' with standardized address
    - Test: valid address includes classification (commercial/residential)
    - Test: ambiguous address returns status 'ambiguous' with candidates
    - Test: invalid address returns status 'invalid' with reason
    - Test: handles missing optional fields gracefully

    Mock apiClient.request with different UPS response scenarios.

    Sample UPS responses for each scenario:

    Valid address:
    ```json
    {
      "XAVResponse": {
        "ValidAddressIndicator": "",
        "Candidate": [{
          "AddressClassification": { "Code": "2", "Description": "Residential" },
          "AddressLine": ["123 MAIN ST"],
          "PoliticalDivision2": "LOS ANGELES",
          "PoliticalDivision1": "CA",
          "PostcodePrimaryLow": "90001",
          "CountryCode": "US"
        }]
      }
    }
    ```

    Ambiguous address:
    ```json
    {
      "XAVResponse": {
        "AmbiguousAddressIndicator": "",
        "Candidate": [
          { "AddressLine": ["123 MAIN ST"], "PoliticalDivision2": "LOS ANGELES", ... },
          { "AddressLine": ["123 MAIN AVE"], "PoliticalDivision2": "LOS ANGELES", ... }
        ]
      }
    }
    ```

    Invalid address:
    ```json
    {
      "XAVResponse": {
        "NoCandidatesIndicator": ""
      }
    }
    ```
  </action>
  <verify>
    cd packages/ups-mcp && pnpm run build
    cd packages/ups-mcp && pnpm test -- address.test.ts
    grep "registerAddressTools" packages/ups-mcp/src/index.ts
  </verify>
  <done>
    Address tool registered with MCP server, tests cover valid/ambiguous/invalid cases
  </done>
</task>

</tasks>

<verification>
All verification commands should pass:

```bash
# Address tools module exists
test -f packages/ups-mcp/src/tools/address.ts && echo "OK: address.ts exists"
grep "address_validate" packages/ups-mcp/src/tools/address.ts

# Output schema includes status enum
grep "valid.*ambiguous.*invalid" packages/ups-mcp/src/tools/address.ts

# Registered with server
grep "registerAddressTools" packages/ups-mcp/src/index.ts

# TypeScript compiles
cd packages/ups-mcp && pnpm run build

# Tests pass
cd packages/ups-mcp && pnpm test -- address.test.ts
```
</verification>

<success_criteria>
- address_validate accepts address fields (line1, line2, city, state, zip, country)
- Valid addresses return status='valid' with standardized/cleaned address
- Valid addresses include classification (commercial vs residential)
- Ambiguous addresses return status='ambiguous' with array of candidates
- Invalid addresses return status='invalid' with reason
- Tool registered with MCP server via registerAddressTools
- Unit tests cover all three scenarios (valid/ambiguous/invalid)
</success_criteria>

<output>
After completion, create `.planning/phases/03-ups-integration-mcp/03-05-SUMMARY.md`
</output>
