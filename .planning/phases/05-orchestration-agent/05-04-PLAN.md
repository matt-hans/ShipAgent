---
phase: 05-orchestration-agent
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - src/orchestrator/agent/client.py
  - src/orchestrator/agent/__init__.py
autonomous: true
user_setup:
  - service: anthropic
    why: "Claude Agent SDK requires Anthropic API key"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Anthropic Console -> API Keys"

must_haves:
  truths:
    - "OrchestrationAgent spawns Data MCP and UPS MCP as child processes on startup"
    - "Agent routes tool calls to appropriate MCP based on mcp__<server>__<tool> naming"
    - "Agent maintains conversation context across multiple user commands"
    - "Agent gracefully shuts down with timeout"
  artifacts:
    - path: "src/orchestrator/agent/client.py"
      provides: "OrchestrationAgent class with ClaudeSDKClient"
      exports: ["OrchestrationAgent", "create_agent"]
  key_links:
    - from: "src/orchestrator/agent/client.py"
      to: "src/orchestrator/agent/config.py"
      via: "MCP server configuration import"
      pattern: "from src\\.orchestrator\\.agent\\.config import"
    - from: "src/orchestrator/agent/client.py"
      to: "src/orchestrator/agent/hooks.py"
      via: "Hook matchers import"
      pattern: "from src\\.orchestrator\\.agent\\.hooks import"
    - from: "src/orchestrator/agent/client.py"
      to: "src/orchestrator/agent/tools.py"
      via: "Orchestrator tools import"
      pattern: "from src\\.orchestrator\\.agent\\.tools import"
---

<objective>
Create the main OrchestrationAgent class that uses ClaudeSDKClient to coordinate MCPs and manage conversation context.

Purpose: Provide the central orchestration layer that spawns MCP servers, routes tool calls, applies hooks, and maintains session continuity per ORCH-01.

Output: Working OrchestrationAgent that can be started, process commands, and stop gracefully.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-orchestration-agent/05-RESEARCH.md
@.planning/phases/05-orchestration-agent/5-orchestration-agent-CONTEXT.md

# Prior plan outputs
@src/orchestrator/agent/config.py
@src/orchestrator/agent/hooks.py
@src/orchestrator/agent/tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OrchestrationAgent Class</name>
  <files>src/orchestrator/agent/client.py</files>
  <action>
Create client.py with the main OrchestrationAgent class.

Per RESEARCH.md:
- Use ClaudeSDKClient (not query()) for session continuity
- Configure MCP servers in ClaudeAgentOptions
- SDK automatically spawns MCP servers and verifies connections
- Use HookMatcher for hook registration

Per CONTEXT.md Decisions:
- Decision 1: Eager spawn at startup, auto-restart on crash, graceful shutdown with 5s timeout
- Decision 2: mcp__<server>__<tool> routing (SDK handles this)
- Decision 4: Session scope is process lifetime

**Implement:**

```python
"""Orchestration Agent using Claude Agent SDK.

The OrchestrationAgent coordinates multiple MCP servers (Data Source, UPS)
via stdio transport, providing a unified interface for natural language
shipping commands.

Per CONTEXT.md:
- MCPs spawn eagerly at startup
- Session persists for process lifetime
- Graceful shutdown with 5s timeout
"""

import asyncio
import sys
from typing import Optional

from claude_agent_sdk import (
    ClaudeSDKClient,
    ClaudeAgentOptions,
    HookMatcher,
    AssistantMessage,
    TextBlock,
    ResultMessage,
    create_sdk_mcp_server,
)

from src.orchestrator.agent.config import create_mcp_servers_config, PROJECT_ROOT
from src.orchestrator.agent.hooks import (
    validate_pre_tool,
    validate_shipping_input,
    log_post_tool,
    detect_error_response,
)
from src.orchestrator.agent.tools import get_orchestrator_tools


class OrchestrationAgent:
    """Main orchestration agent coordinating MCPs via Claude Agent SDK.

    Manages the lifecycle of Data Source MCP and UPS MCP as child processes,
    routes tool calls through hooks, and maintains conversation context.

    Usage:
        agent = OrchestrationAgent()
        await agent.start()
        try:
            response = await agent.process_command("Import orders.csv")
            print(response)
        finally:
            await agent.stop()
    """

    def __init__(
        self,
        max_turns: int = 50,
        permission_mode: str = "acceptEdits",
    ) -> None:
        """Initialize the Orchestration Agent.

        Args:
            max_turns: Maximum conversation turns before requiring reset.
            permission_mode: SDK permission mode for file operations.
        """
        self._options = self._create_options(max_turns, permission_mode)
        self._client: Optional[ClaudeSDKClient] = None
        self._started = False

    def _create_options(self, max_turns: int, permission_mode: str) -> ClaudeAgentOptions:
        """Create ClaudeAgentOptions with MCP servers and hooks."""

        # Get orchestrator tools for SDK MCP server
        orchestrator_tools = get_orchestrator_tools()

        # Create SDK MCP server for orchestrator tools
        orchestrator_mcp = create_sdk_mcp_server(
            name="orchestrator",
            tools=[
                (tool["name"], tool["description"], tool["schema"], tool["function"])
                for tool in orchestrator_tools
            ]
        )

        # Get MCP server configs
        mcp_configs = create_mcp_servers_config()

        return ClaudeAgentOptions(
            mcp_servers={
                # In-process orchestrator tools
                "orchestrator": orchestrator_mcp,
                # External MCP servers (stdio child processes)
                "data": mcp_configs["data"],
                "ups": mcp_configs["ups"],
            },

            # Allow all tools from configured MCPs
            allowed_tools=[
                "mcp__orchestrator__*",
                "mcp__data__*",
                "mcp__ups__*",
            ],

            # Hook configuration
            hooks={
                "PreToolUse": [
                    HookMatcher(
                        matcher="mcp__ups__shipping",
                        hooks=[validate_shipping_input]
                    ),
                    HookMatcher(
                        matcher=None,  # All tools
                        hooks=[validate_pre_tool]
                    ),
                ],
                "PostToolUse": [
                    HookMatcher(
                        matcher=None,  # All tools
                        hooks=[log_post_tool, detect_error_response]
                    ),
                ],
            },

            # Session settings
            permission_mode=permission_mode,
            max_turns=max_turns,
        )

    async def start(self) -> None:
        """Start the agent and spawn MCP servers.

        Raises:
            RuntimeError: If agent is already started.
        """
        if self._started:
            raise RuntimeError("Agent already started")

        print("[OrchestrationAgent] Starting...", file=sys.stderr)

        self._client = ClaudeSDKClient(self._options)
        await self._client.connect()

        self._started = True
        print("[OrchestrationAgent] Started successfully", file=sys.stderr)

    async def process_command(self, user_input: str) -> str:
        """Process a user command and return the response.

        The client maintains conversation context across calls.

        Args:
            user_input: Natural language command from the user.

        Returns:
            Agent's text response.

        Raises:
            RuntimeError: If agent not started.
        """
        if not self._started or self._client is None:
            raise RuntimeError("Agent not started. Call start() first.")

        await self._client.query(user_input)

        response_parts: list[str] = []
        async for message in self._client.receive_response():
            if isinstance(message, AssistantMessage):
                for block in message.content:
                    if isinstance(block, TextBlock):
                        response_parts.append(block.text)
            elif isinstance(message, ResultMessage):
                if message.subtype == "error":
                    response_parts.append(f"[Error: {message.result}]")
                break

        return "".join(response_parts)

    async def stop(self, timeout: float = 5.0) -> None:
        """Stop the agent gracefully.

        Per CONTEXT.md Decision 1: Graceful shutdown with 5s timeout.

        Args:
            timeout: Seconds to wait for graceful shutdown before force kill.
        """
        if not self._started:
            return

        print("[OrchestrationAgent] Stopping...", file=sys.stderr)

        if self._client:
            try:
                await asyncio.wait_for(
                    self._client.disconnect(),
                    timeout=timeout
                )
            except asyncio.TimeoutError:
                print(
                    f"[OrchestrationAgent] Shutdown timed out after {timeout}s",
                    file=sys.stderr
                )

        self._started = False
        self._client = None
        print("[OrchestrationAgent] Stopped", file=sys.stderr)

    @property
    def is_started(self) -> bool:
        """Check if the agent is currently running."""
        return self._started


async def create_agent() -> OrchestrationAgent:
    """Factory function to create and start an OrchestrationAgent.

    Returns:
        Started OrchestrationAgent ready for commands.

    Example:
        agent = await create_agent()
        try:
            response = await agent.process_command("Import orders.csv")
        finally:
            await agent.stop()
    """
    agent = OrchestrationAgent()
    await agent.start()
    return agent
```

NOTE: The exact Claude Agent SDK API may differ slightly. Check imports work and adjust if needed.
  </action>
  <verify>
```bash
# First check if claude-agent-sdk is installed
pip show claude-agent-sdk 2>/dev/null || pip install claude-agent-sdk

# Then verify imports work
python -c "
from src.orchestrator.agent.client import OrchestrationAgent, create_agent
print('OrchestrationAgent importable')

# Check class structure
agent = OrchestrationAgent()
assert hasattr(agent, 'start')
assert hasattr(agent, 'stop')
assert hasattr(agent, 'process_command')
assert hasattr(agent, 'is_started')
print('OrchestrationAgent structure validated')
"
```
  </verify>
  <done>OrchestrationAgent class implemented with lifecycle management and command processing</done>
</task>

<task type="auto">
  <name>Task 2: Add Context Manager Support</name>
  <files>src/orchestrator/agent/client.py</files>
  <action>
Add async context manager support to OrchestrationAgent for cleaner resource management.

**Add to OrchestrationAgent class:**

```python
    async def __aenter__(self) -> "OrchestrationAgent":
        """Async context manager entry - start the agent."""
        await self.start()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        """Async context manager exit - stop the agent."""
        await self.stop()
```

This enables usage like:
```python
async with OrchestrationAgent() as agent:
    response = await agent.process_command("Import orders.csv")
    print(response)
# Agent automatically stopped on exit
```
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.agent.client import OrchestrationAgent
import asyncio

async def test_context_manager():
    agent = OrchestrationAgent()
    assert hasattr(agent, '__aenter__')
    assert hasattr(agent, '__aexit__')
    # Don't actually enter context (would try to connect)
    print('Context manager methods present')

asyncio.run(test_context_manager())
"
```
  </verify>
  <done>OrchestrationAgent supports async context manager pattern</done>
</task>

<task type="auto">
  <name>Task 3: Update Package Exports</name>
  <files>src/orchestrator/agent/__init__.py</files>
  <action>
Update src/orchestrator/agent/__init__.py to export the full agent API.

```python
"""Orchestration Agent package for ShipAgent.

This package provides the Claude Agent SDK-based orchestration layer that
coordinates multiple MCP servers (Data Source, UPS) via stdio transport.

Main Entry Points:
    OrchestrationAgent: Main agent class with lifecycle management
    create_agent: Factory to create and start an agent

Configuration:
    create_mcp_servers_config: Get MCP server configurations
    create_hook_matchers: Get hook configurations

Per CONTEXT.md:
- MCPs spawn eagerly at startup
- Session persists for process lifetime
- Graceful shutdown with 5s timeout
"""

# Configuration
from src.orchestrator.agent.config import (
    PROJECT_ROOT,
    MCPServerConfig,
    get_data_mcp_config,
    get_ups_mcp_config,
    create_mcp_servers_config,
)

# Hooks
from src.orchestrator.agent.hooks import (
    validate_pre_tool,
    validate_shipping_input,
    validate_data_query,
    log_post_tool,
    detect_error_response,
    create_hook_matchers,
)

# Tools
from src.orchestrator.agent.tools import (
    process_command_tool,
    get_job_status_tool,
    list_tools_tool,
    get_orchestrator_tools,
)

# Client
from src.orchestrator.agent.client import (
    OrchestrationAgent,
    create_agent,
)

__all__ = [
    # Main entry points
    "OrchestrationAgent",
    "create_agent",
    # Configuration
    "PROJECT_ROOT",
    "MCPServerConfig",
    "get_data_mcp_config",
    "get_ups_mcp_config",
    "create_mcp_servers_config",
    # Hooks
    "validate_pre_tool",
    "validate_shipping_input",
    "validate_data_query",
    "log_post_tool",
    "detect_error_response",
    "create_hook_matchers",
    # Tools
    "process_command_tool",
    "get_job_status_tool",
    "list_tools_tool",
    "get_orchestrator_tools",
]
```
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.agent import (
    OrchestrationAgent,
    create_agent,
    create_mcp_servers_config,
    create_hook_matchers,
    get_orchestrator_tools,
)
print('All agent exports available')
print(f'OrchestrationAgent: {OrchestrationAgent}')
print(f'create_agent: {create_agent}')
"
```
  </verify>
  <done>Agent package exports complete API for orchestration</done>
</task>

</tasks>

<verification>
1. OrchestrationAgent class implements start/stop/process_command
2. ClaudeAgentOptions configured with all MCP servers
3. Hooks properly registered with HookMatcher
4. Context manager support for clean resource management
5. Package exports provide full agent API
</verification>

<success_criteria>
1. `OrchestrationAgent` can be instantiated with valid options
2. MCP servers configured for data and ups namespaces
3. Hooks registered for PreToolUse and PostToolUse
4. `async with OrchestrationAgent()` works as context manager
5. All exports importable from `src.orchestrator.agent`
</success_criteria>

<output>
After completion, create `.planning/phases/05-orchestration-agent/05-04-SUMMARY.md`
</output>
