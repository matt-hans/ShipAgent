---
phase: 05-orchestration-agent
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestrator/agent/hooks.py
autonomous: true

must_haves:
  truths:
    - "Pre-tool hooks validate inputs before MCP execution"
    - "Post-tool hooks log all tool executions for audit"
    - "Pre-hook failures block tool calls with clear error messages"
    - "Hooks use HookMatcher for tool name pattern matching"
  artifacts:
    - path: "src/orchestrator/agent/hooks.py"
      provides: "PreToolUse and PostToolUse hook implementations"
      exports: ["validate_pre_tool", "log_post_tool", "validate_shipping_input", "create_hook_matchers"]
  key_links:
    - from: "src/orchestrator/agent/hooks.py"
      to: "claude_agent_sdk"
      via: "HookMatcher and HookContext imports"
      pattern: "from claude_agent_sdk import.*HookMatcher"
---

<objective>
Implement the hook system for pre-tool validation and post-tool logging that intercepts MCP tool calls.

Purpose: Provide the validation and audit layer that ensures tool inputs are valid before execution and all executions are logged per ORCH-05.

Output: Hook functions ready to be registered in ClaudeAgentOptions.hooks configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-orchestration-agent/05-RESEARCH.md
@.planning/phases/05-orchestration-agent/5-orchestration-agent-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pre-Tool Validation Hooks</name>
  <files>src/orchestrator/agent/hooks.py</files>
  <action>
Create hooks.py with PreToolUse hook implementations.

Per RESEARCH.md and CONTEXT.md Decision 3:
- Pre-hooks validate schema and business rules
- Hooks can reject but never modify inputs (validate only)
- Return permissionDecision: "deny" with permissionDecisionReason on failure

**Implement:**

1. **validate_shipping_input(input_data, tool_use_id, context)** - UPS shipping validation
   ```python
   async def validate_shipping_input(
       input_data: dict[str, Any],
       tool_use_id: str | None,
       context: Any
   ) -> dict[str, Any]:
   ```

   Validates:
   - For `mcp__ups__shipping_create`: Require shipper and shipTo fields
   - Return denial with clear reason if missing
   - Return empty dict `{}` to allow operation

   Denial format per RESEARCH.md:
   ```python
   return {
       "hookSpecificOutput": {
           "hookEventName": "PreToolUse",
           "permissionDecision": "deny",
           "permissionDecisionReason": "Missing required shipper information"
       }
   }
   ```

2. **validate_data_query(input_data, tool_use_id, context)** - Data query validation
   - For `mcp__data__query_data`: Warn if no WHERE clause on large data (informational, don't block)
   - For dangerous operations, could add blocking rules

3. **validate_pre_tool(input_data, tool_use_id, context)** - Generic pre-validation
   - Entry point that routes to specific validators based on tool_name
   - Extract tool_name and tool_input from input_data
   - Log the validation attempt to stderr (per RESEARCH.md: never use stdout)

DO NOT:
- Modify input_data (hooks validate only per CONTEXT.md Decision 3)
- Import from claude_agent_sdk (use TYPE_CHECKING to avoid import errors if SDK not installed yet)
- Create the HookMatcher registration yet (that's in Plan 04)
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.agent.hooks import validate_shipping_input, validate_data_query, validate_pre_tool
import asyncio

# Test shipping validation - missing required fields
result = asyncio.run(validate_shipping_input(
    {'tool_name': 'mcp__ups__shipping_create', 'tool_input': {}},
    'test-id',
    None
))
assert 'hookSpecificOutput' in result
assert result['hookSpecificOutput']['permissionDecision'] == 'deny'
print('Pre-hook validation works')
"
```
  </verify>
  <done>Pre-tool validation hooks implemented with denial mechanism for invalid inputs</done>
</task>

<task type="auto">
  <name>Task 2: Create Post-Tool Logging Hooks</name>
  <files>src/orchestrator/agent/hooks.py</files>
  <action>
Add PostToolUse hook implementations to hooks.py.

Per RESEARCH.md and CONTEXT.md Decision 3:
- Post-hooks check response for error indicators
- Post-hooks log all tool calls with timing information
- Post-hooks can trigger error handling flow if needed

**Implement:**

1. **log_post_tool(input_data, tool_use_id, context)** - Audit logging
   ```python
   async def log_post_tool(
       input_data: dict[str, Any],
       tool_use_id: str | None,
       context: Any
   ) -> dict[str, Any]:
   ```

   Actions:
   - Extract tool_name from input_data
   - Extract tool_response from input_data
   - Determine success/failure from response content
   - Log to stderr with: tool_name, tool_use_id, success status, timing if available
   - Return empty dict `{}` (post-hooks don't modify flow)

   Log format: `[AUDIT] Tool: {tool_name} | ID: {tool_use_id} | Success: {bool}`

2. **detect_error_response(input_data, tool_use_id, context)** - Error detection
   - Check tool_response for common error indicators
   - Look for "error" keys, HTTP error status patterns
   - Log warnings for detected errors
   - Return empty dict (informational only)

3. **Helper function _is_error_response(response)** - Check if response indicates error
   - Handle dict responses with "error" or "isError" keys
   - Handle string responses containing "error" patterns
   - Return bool

Per CONTEXT.md: Hooks log to stderr, never stdout (stdout is MCP protocol)
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.agent.hooks import log_post_tool, detect_error_response
import asyncio

# Test post-tool logging
result = asyncio.run(log_post_tool(
    {
        'tool_name': 'mcp__data__get_schema',
        'tool_response': {'columns': ['id', 'name']}
    },
    'test-id',
    None
))
assert result == {}
print('Post-hook logging works')
"
```
  </verify>
  <done>Post-tool hooks implemented for audit logging and error detection</done>
</task>

<task type="auto">
  <name>Task 3: Create Hook Matcher Factory</name>
  <files>src/orchestrator/agent/hooks.py</files>
  <action>
Add function to create HookMatcher configurations for ClaudeAgentOptions.

**Implement:**

1. **create_hook_matchers()** - Returns hook configuration dict
   ```python
   def create_hook_matchers() -> dict[str, list[dict[str, Any]]]:
       """Create hook matchers for ClaudeAgentOptions.hooks configuration.

       Returns dict ready for ClaudeAgentOptions(hooks=create_hook_matchers()).

       Structure:
       {
           "PreToolUse": [
               {"matcher": "mcp__ups__shipping", "hooks": [validate_shipping_input]},
               {"matcher": None, "hooks": [validate_pre_tool]}  # All tools
           ],
           "PostToolUse": [
               {"matcher": None, "hooks": [log_post_tool, detect_error_response]}
           ]
       }
       """
   ```

   Per RESEARCH.md:
   - matcher=None means "all tools"
   - matcher="mcp__ups__shipping" means "tools starting with that prefix"
   - UPS shipping tools get extra validation
   - All tools get post-execution logging

2. Update module exports in hooks.py:
   ```python
   __all__ = [
       "validate_pre_tool",
       "validate_shipping_input",
       "validate_data_query",
       "log_post_tool",
       "detect_error_response",
       "create_hook_matchers",
   ]
   ```

NOTE: The actual HookMatcher class will be used in Plan 04 when we create ClaudeAgentOptions. For now, return the configuration as plain dicts that describe the matchers.
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.agent.hooks import create_hook_matchers
matchers = create_hook_matchers()
assert 'PreToolUse' in matchers
assert 'PostToolUse' in matchers
assert len(matchers['PreToolUse']) >= 1
assert len(matchers['PostToolUse']) >= 1
print('Hook matchers factory works')
"
```
  </verify>
  <done>Hook matcher factory ready for ClaudeAgentOptions integration</done>
</task>

</tasks>

<verification>
1. Pre-tool hooks validate and can deny operations
2. Post-tool hooks log all executions to stderr
3. Error detection identifies failed tool responses
4. Hook matchers factory returns proper configuration structure
5. All functions are async and handle the expected input_data format
</verification>

<success_criteria>
1. `validate_shipping_input` blocks calls missing shipper/shipTo with clear error
2. `log_post_tool` logs every tool execution to stderr
3. `create_hook_matchers()` returns configuration for both PreToolUse and PostToolUse
4. Hooks never modify input/output data (validate only per CONTEXT.md)
</success_criteria>

<output>
After completion, create `.planning/phases/05-orchestration-agent/05-02-SUMMARY.md`
</output>
