---
phase: 06-batch-execution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestrator/batch/__init__.py
  - src/orchestrator/batch/modes.py
  - src/orchestrator/batch/events.py
  - src/orchestrator/batch/models.py
  - tests/unit/orchestrator/batch/test_modes.py
  - tests/unit/orchestrator/batch/test_events.py
autonomous: true

must_haves:
  truths:
    - "ExecutionMode enum defines CONFIRM and AUTO modes"
    - "Session mode defaults to CONFIRM"
    - "Mode can be changed mid-session but not mid-execution"
    - "Lifecycle events can be subscribed to by observers"
    - "BatchResult captures all execution outcomes"
  artifacts:
    - path: "src/orchestrator/batch/modes.py"
      provides: "ExecutionMode enum and session mode manager"
      min_lines: 40
      exports: ["ExecutionMode", "SessionModeManager"]
    - path: "src/orchestrator/batch/events.py"
      provides: "Observer pattern for batch lifecycle events"
      min_lines: 60
      exports: ["BatchEventObserver", "BatchEventEmitter"]
    - path: "src/orchestrator/batch/models.py"
      provides: "BatchResult, PreviewRow, BatchPreview dataclasses"
      min_lines: 80
      exports: ["BatchResult", "PreviewRow", "BatchPreview"]
  key_links:
    - from: "src/orchestrator/batch/events.py"
      to: "observers"
      via: "Protocol/ABC pattern"
      pattern: "class BatchEventObserver.*Protocol"
---

<objective>
Create the foundational types and patterns for the Batch Execution Engine.

Purpose: Before implementing the BatchExecutor, we need the supporting infrastructure: execution modes (BATCH-04), lifecycle events (for progress tracking), and result models. This establishes the contracts that the executor will implement.

Output: New `src/orchestrator/batch/` package with modes, events, and models modules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-batch-execution/06-CONTEXT.md
@.planning/phases/06-batch-execution/06-RESEARCH.md

# Existing orchestrator structure
@src/orchestrator/__init__.py
@src/orchestrator/models/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create batch package with modes module</name>
  <files>src/orchestrator/batch/__init__.py, src/orchestrator/batch/modes.py</files>
  <action>
Create the `src/orchestrator/batch/` package directory and files.

`src/orchestrator/batch/__init__.py`:
```python
"""Batch execution engine for ShipAgent.

Provides batch shipment processing with preview mode, fail-fast error
handling, and crash recovery support.
"""

from src.orchestrator.batch.modes import ExecutionMode, SessionModeManager
from src.orchestrator.batch.events import BatchEventObserver, BatchEventEmitter
from src.orchestrator.batch.models import BatchResult, PreviewRow, BatchPreview

__all__ = [
    "ExecutionMode",
    "SessionModeManager",
    "BatchEventObserver",
    "BatchEventEmitter",
    "BatchResult",
    "PreviewRow",
    "BatchPreview",
]
```

`src/orchestrator/batch/modes.py`:
1. Create `ExecutionMode` enum (str, Enum) with:
   - `CONFIRM = "confirm"` - Preview before execute (default)
   - `AUTO = "auto"` - Execute immediately

2. Create `SessionModeManager` class:
   - `__init__(self)`: Initialize with `_mode = ExecutionMode.CONFIRM`, `_locked = False`
   - `@property mode(self) -> ExecutionMode`: Return current mode
   - `set_mode(self, mode: ExecutionMode) -> None`: Set mode if not locked, raise ValueError if locked
   - `lock(self) -> None`: Set `_locked = True` (called when batch starts)
   - `unlock(self) -> None`: Set `_locked = False` (called when batch ends)
   - `is_locked(self) -> bool`: Return lock status
   - `reset(self) -> None`: Reset to CONFIRM mode and unlock (for new session)

Per CONTEXT.md Decision 2:
- Default mode: confirm
- Mid-preview switch: allowed (not locked during preview)
- Mid-execution switch: not allowed (locked during execution)
  </action>
  <verify>
Run `python -c "from src.orchestrator.batch.modes import ExecutionMode, SessionModeManager; m = SessionModeManager(); print(m.mode)"`
  </verify>
  <done>
ExecutionMode enum and SessionModeManager class exist with mode tracking and locking behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create events module with Observer pattern</name>
  <files>src/orchestrator/batch/events.py</files>
  <action>
Create `src/orchestrator/batch/events.py` implementing the Observer pattern for batch lifecycle events.

1. Create `BatchEventObserver` Protocol (typing.Protocol):
```python
class BatchEventObserver(Protocol):
    """Observer protocol for batch lifecycle events."""

    async def on_batch_started(self, job_id: str, total_rows: int) -> None: ...
    async def on_row_started(self, job_id: str, row_number: int) -> None: ...
    async def on_row_completed(self, job_id: str, row_number: int, tracking_number: str, cost_cents: int) -> None: ...
    async def on_row_failed(self, job_id: str, row_number: int, error_code: str, error_message: str) -> None: ...
    async def on_batch_completed(self, job_id: str, total_rows: int, successful: int, total_cost_cents: int) -> None: ...
    async def on_batch_failed(self, job_id: str, error_code: str, error_message: str, processed: int) -> None: ...
```

2. Create `BatchEventEmitter` class:
   - `__init__(self)`: Initialize empty `_observers: list[BatchEventObserver]`
   - `add_observer(self, observer: BatchEventObserver) -> None`: Append to list
   - `remove_observer(self, observer: BatchEventObserver) -> None`: Remove from list
   - `async emit_batch_started(self, job_id: str, total_rows: int) -> None`: Call all observers
   - `async emit_row_started(...)`, `emit_row_completed(...)`, `emit_row_failed(...)`: Similar
   - `async emit_batch_completed(...)`, `emit_batch_failed(...)`: Similar

Each emit method should catch and log exceptions from individual observers (don't let one broken observer stop others).

Per CLAUDE.md "Observer pattern for lifecycle events" - this enables Phase 7 UI to subscribe for progress updates.
  </action>
  <verify>
Run `python -c "from src.orchestrator.batch.events import BatchEventObserver, BatchEventEmitter; print('OK')"`
  </verify>
  <done>
BatchEventObserver Protocol and BatchEventEmitter class exist with all lifecycle event methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create models module with result dataclasses</name>
  <files>src/orchestrator/batch/models.py, tests/unit/orchestrator/batch/test_modes.py, tests/unit/orchestrator/batch/test_events.py</files>
  <action>
Create `src/orchestrator/batch/models.py` with dataclasses for batch operations.

1. `PreviewRow` dataclass:
```python
@dataclass
class PreviewRow:
    """Single row in preview display."""
    row_number: int
    recipient_name: str
    city_state: str
    service: str
    estimated_cost_cents: int
    warnings: list[str]
```

2. `BatchPreview` dataclass:
```python
@dataclass
class BatchPreview:
    """Preview of batch before execution."""
    job_id: str
    total_rows: int
    preview_rows: list[PreviewRow]  # First 20 rows per CONTEXT.md
    additional_rows: int  # Rows beyond preview
    total_estimated_cost_cents: int
    rows_with_warnings: int
```

3. `BatchResult` dataclass:
```python
@dataclass
class BatchResult:
    """Result of batch execution."""
    success: bool
    job_id: str
    total_rows: int
    processed_rows: int
    successful_rows: int
    failed_rows: int
    total_cost_cents: int
    error_code: Optional[str] = None
    error_message: Optional[str] = None
```

4. `InterruptedJobInfo` dataclass (for crash recovery):
```python
@dataclass
class InterruptedJobInfo:
    """Information about an interrupted job for recovery prompt."""
    job_id: str
    job_name: str
    completed_rows: int
    total_rows: int
    remaining_rows: int
    last_row_number: Optional[int]
    last_tracking_number: Optional[str]
    error_code: Optional[str]
    error_message: Optional[str]
```

Then create unit tests:

`tests/unit/orchestrator/batch/__init__.py` (empty)

`tests/unit/orchestrator/batch/test_modes.py`:
- test_default_mode_is_confirm
- test_set_mode_to_auto
- test_locked_mode_raises_error
- test_unlock_allows_change
- test_reset_returns_to_confirm

`tests/unit/orchestrator/batch/test_events.py`:
- test_add_observer
- test_emit_calls_all_observers (use AsyncMock)
- test_observer_exception_doesnt_stop_others
- test_remove_observer
  </action>
  <verify>
Run `pytest tests/unit/orchestrator/batch/ -v`
  </verify>
  <done>
All dataclasses created. Unit tests for modes and events pass.
  </done>
</task>

</tasks>

<verification>
- [ ] `from src.orchestrator.batch import ExecutionMode, SessionModeManager` works
- [ ] `from src.orchestrator.batch import BatchEventObserver, BatchEventEmitter` works
- [ ] `from src.orchestrator.batch import BatchResult, PreviewRow, BatchPreview` works
- [ ] Mode manager defaults to CONFIRM and supports locking
- [ ] Event emitter calls all observers and handles exceptions gracefully
- [ ] All unit tests pass
</verification>

<success_criteria>
- ExecutionMode enum with CONFIRM (default) and AUTO values
- SessionModeManager with lock/unlock for mid-execution protection
- BatchEventObserver Protocol for lifecycle events
- BatchEventEmitter with emit methods for all events
- Dataclasses for PreviewRow, BatchPreview, BatchResult, InterruptedJobInfo
- Unit tests pass for modes and events
</success_criteria>

<output>
After completion, create `.planning/phases/06-batch-execution/06-02-SUMMARY.md`
</output>
