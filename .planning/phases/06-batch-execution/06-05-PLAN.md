---
phase: 06-batch-execution
plan: 05
type: execute
wave: 3
depends_on: ["06-03", "06-04"]
files_modified:
  - src/orchestrator/batch/recovery.py
  - src/orchestrator/batch/__init__.py
  - tests/unit/orchestrator/batch/test_recovery.py
autonomous: true

must_haves:
  truths:
    - "System detects jobs in 'running' state as interrupted"
    - "Recovery prompt shows progress and last processed row"
    - "User can choose: resume, restart, or cancel"
    - "Resume starts from first pending row"
    - "Restart warns about duplicate shipments"
  artifacts:
    - path: "src/orchestrator/batch/recovery.py"
      provides: "Crash recovery detection and prompts"
      min_lines: 80
      exports: ["check_interrupted_jobs", "get_recovery_prompt", "handle_recovery_choice"]
    - path: "tests/unit/orchestrator/batch/test_recovery.py"
      provides: "Unit tests for crash recovery"
      min_lines: 60
  key_links:
    - from: "src/orchestrator/batch/recovery.py"
      to: "src/services/job_service.py"
      via: "JobService queries"
      pattern: "job_service\\.list_jobs|get_rows"
---

<objective>
Implement crash recovery detection and user prompts for interrupted batches.

Purpose: BATCH-06 requires tracking per-row state for crash recovery. This plan implements the UX for detecting and recovering from interrupted jobs (per CONTEXT.md Decision 3).

Output: Recovery module with detection, prompts, and handling for interrupted jobs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-batch-execution/06-CONTEXT.md
@.planning/phases/06-batch-execution/06-RESEARCH.md

# Dependencies
@src/orchestrator/batch/models.py
@src/services/job_service.py
@src/db/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recovery module</name>
  <files>src/orchestrator/batch/recovery.py</files>
  <action>
Create `src/orchestrator/batch/recovery.py` with crash recovery utilities.

```python
"""Crash recovery for interrupted batch jobs.

Per CONTEXT.md Decision 3:
- Resume: Prompt user with progress info
- Options: Resume, Restart, Cancel
- Restart warns about duplicate shipments
- Show last error if crash was due to error
"""

from enum import Enum
from typing import Optional

from src.db.models import JobStatus, RowStatus
from src.services.job_service import JobService
from src.orchestrator.batch.models import InterruptedJobInfo


class RecoveryChoice(str, Enum):
    """User choices for interrupted job recovery."""
    RESUME = "resume"
    RESTART = "restart"
    CANCEL = "cancel"


def check_interrupted_jobs(job_service: JobService) -> Optional[InterruptedJobInfo]:
    """Check for jobs interrupted mid-execution.

    Finds jobs in 'running' state, which indicates they were interrupted
    (normal completion transitions to 'completed' or 'failed').

    Args:
        job_service: JobService instance for database queries

    Returns:
        InterruptedJobInfo if found, None otherwise
    """
    # Find jobs in 'running' state (indicates crash)
    interrupted = job_service.list_jobs(status=JobStatus.running, limit=1)

    if not interrupted:
        return None

    job = interrupted[0]

    # Get progress info
    completed_count = job.successful_rows
    total = job.total_rows
    remaining = total - job.processed_rows

    # Get last completed row info
    completed_rows = job_service.get_rows(job.id, status=RowStatus.completed)
    last_row_info = None
    last_tracking = None
    if completed_rows:
        last = completed_rows[-1]
        last_row_info = last.row_number
        last_tracking = last.tracking_number

    return InterruptedJobInfo(
        job_id=job.id,
        job_name=job.name,
        completed_rows=completed_count,
        total_rows=total,
        remaining_rows=remaining,
        last_row_number=last_row_info,
        last_tracking_number=last_tracking,
        error_code=job.error_code,
        error_message=job.error_message,
    )


def get_recovery_prompt(info: InterruptedJobInfo) -> str:
    """Generate user-friendly recovery prompt.

    Per CONTEXT.md Decision 3:
    - Summary: "47/200 complete. Last: Row 47 (John Doe, tracking ABC123). 153 remaining."
    - Error context if exists: "Crashed at row 48 due to: UPS API timeout"

    Args:
        info: InterruptedJobInfo from check_interrupted_jobs

    Returns:
        Formatted prompt string
    """
    lines = [
        f"Job '{info.job_name}' was interrupted at row {info.completed_rows}/{info.total_rows}.",
        "",
    ]

    if info.last_row_number and info.last_tracking_number:
        lines.append(
            f"Last completed: Row {info.last_row_number} (tracking: {info.last_tracking_number})"
        )

    lines.append(f"Remaining: {info.remaining_rows} rows")

    if info.error_code and info.error_message:
        lines.extend([
            "",
            f"Last error: {info.error_code}: {info.error_message}",
            "Resume will retry from the failed row.",
        ])

    lines.extend([
        "",
        "Options:",
        "  [resume]  - Continue from where it stopped",
        "  [restart] - Start over from the beginning (may create duplicates!)",
        "  [cancel]  - Abandon this job",
    ])

    return "\n".join(lines)


def handle_recovery_choice(
    choice: RecoveryChoice,
    job_id: str,
    job_service: JobService,
) -> dict:
    """Handle user's recovery choice.

    Args:
        choice: User's selected action
        job_id: UUID of the interrupted job
        job_service: JobService for state updates

    Returns:
        Dict with action result and any warnings
    """
    if choice == RecoveryChoice.RESUME:
        # No state changes needed - executor will process pending rows
        return {
            "action": "resume",
            "job_id": job_id,
            "message": "Resuming from last checkpoint. Pending rows will be processed.",
        }

    elif choice == RecoveryChoice.RESTART:
        # Reset all rows to pending
        job = job_service.get_job(job_id)
        if not job:
            raise ValueError(f"Job {job_id} not found")

        # Get all rows and reset to pending
        all_rows = job_service.get_rows(job_id)
        completed_count = sum(1 for r in all_rows if r.status == RowStatus.completed.value)

        # Reset row statuses (this would need a new JobService method or direct update)
        # For now, return warning about duplicates
        return {
            "action": "restart",
            "job_id": job_id,
            "warning": f"WARNING: {completed_count} rows already have tracking numbers. "
                       "Restarting will create duplicate shipments for these rows. "
                       "Consider using 'resume' instead.",
            "requires_confirmation": True,
            "completed_rows_with_tracking": completed_count,
        }

    elif choice == RecoveryChoice.CANCEL:
        # Transition job to cancelled
        job_service.update_status(job_id, JobStatus.cancelled)
        return {
            "action": "cancel",
            "job_id": job_id,
            "message": "Job cancelled. No further rows will be processed.",
        }

    else:
        raise ValueError(f"Unknown recovery choice: {choice}")
```
  </action>
  <verify>
Run `python -c "from src.orchestrator.batch.recovery import check_interrupted_jobs, get_recovery_prompt, RecoveryChoice; print('OK')"`
  </verify>
  <done>
Recovery module exists with check_interrupted_jobs, get_recovery_prompt, handle_recovery_choice, and RecoveryChoice enum.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update batch package exports</name>
  <files>src/orchestrator/batch/__init__.py</files>
  <action>
Update `src/orchestrator/batch/__init__.py` to export recovery utilities.

Add imports:
```python
from src.orchestrator.batch.recovery import (
    check_interrupted_jobs,
    get_recovery_prompt,
    handle_recovery_choice,
    RecoveryChoice,
)
```

Add to __all__:
```python
__all__ = [
    # ... existing exports
    "check_interrupted_jobs",
    "get_recovery_prompt",
    "handle_recovery_choice",
    "RecoveryChoice",
]
```
  </action>
  <verify>
Run `python -c "from src.orchestrator.batch import check_interrupted_jobs, RecoveryChoice; print('OK')"`
  </verify>
  <done>
Recovery utilities are exported from the batch package.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for recovery</name>
  <files>tests/unit/orchestrator/batch/test_recovery.py</files>
  <action>
Create unit tests for crash recovery functionality.

Test setup:
- Mock JobService with in-memory state
- Create jobs in various states

Test cases:

1. `test_check_interrupted_no_jobs`:
   - No jobs in running state
   - Returns None

2. `test_check_interrupted_finds_job`:
   - Job in running state with partial completion
   - Returns InterruptedJobInfo with correct counts

3. `test_check_interrupted_with_error`:
   - Job has error_code and error_message set
   - Info includes error details

4. `test_get_recovery_prompt_basic`:
   - Generates readable prompt with progress

5. `test_get_recovery_prompt_with_error`:
   - Includes error info when present

6. `test_handle_resume`:
   - Returns action="resume" with no state changes

7. `test_handle_restart_warning`:
   - Returns warning about duplicates
   - Includes count of completed rows

8. `test_handle_cancel`:
   - Transitions job to cancelled state

Use pytest fixtures for job setup.
  </action>
  <verify>
Run `pytest tests/unit/orchestrator/batch/test_recovery.py -v`
  </verify>
  <done>
All recovery tests pass covering detection, prompts, and all three recovery choices.
  </done>
</task>

</tasks>

<verification>
- [ ] check_interrupted_jobs finds jobs in 'running' state
- [ ] InterruptedJobInfo includes progress and error info
- [ ] get_recovery_prompt generates readable message
- [ ] handle_recovery_choice handles resume, restart, cancel
- [ ] Restart warns about duplicate shipments
- [ ] Cancel transitions job to cancelled state
- [ ] All unit tests pass
</verification>

<success_criteria>
- Interrupted jobs detected (running state = crash indicator)
- User-friendly prompt with progress info per CONTEXT.md Decision 3
- All three recovery options implemented
- Restart includes duplicate shipment warning
- Unit tests cover all scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/06-batch-execution/06-05-SUMMARY.md`
</output>
