---
phase: 04-nl-mapping-engine
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/orchestrator/models/mapping.py
  - src/orchestrator/nl_engine/mapping_generator.py
  - src/orchestrator/filters/__init__.py
  - src/orchestrator/filters/logistics.py
  - tests/orchestrator/test_mapping_generator.py
autonomous: true

must_haves:
  truths:
    - "System generates Jinja2 template mapping source columns to UPS ShipTo fields"
    - "User can provide explicit column mappings (customer_name -> ShipTo.Name)"
    - "Template includes Jinja2 filters for transformations (truncate_address, format_phone)"
  artifacts:
    - path: "src/orchestrator/models/mapping.py"
      provides: "FieldMapping, MappingTemplate Pydantic models"
      exports: ["FieldMapping", "MappingTemplate"]
    - path: "src/orchestrator/nl_engine/mapping_generator.py"
      provides: "generate_mapping_template, suggest_mappings functions"
      exports: ["generate_mapping_template", "suggest_mappings", "MappingGenerationError"]
    - path: "src/orchestrator/filters/logistics.py"
      provides: "Jinja2 logistics filter library"
      exports: ["get_logistics_environment", "LOGISTICS_FILTERS"]
  key_links:
    - from: "mapping_generator.py"
      to: "jinja2.Environment"
      via: "template compilation"
      pattern: "env\\.from_string"
    - from: "logistics.py"
      to: "jinja2 filters"
      via: "filter registration"
      pattern: "env\\.filters\\["
---

<objective>
Create the mapping template generator that transforms source data schemas to UPS payload format.

Purpose: Enable automatic generation of Jinja2 mapping templates that transform user data (CSV/Excel columns) into valid UPS API payloads, with explicit user confirmation of mappings per CONTEXT.md Decision 2.

Output: Mapping models, a template generator with LLM suggestions, and the logistics filter library for common transformations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-nl-mapping-engine/04-CONTEXT.md
@.planning/phases/04-nl-mapping-engine/04-RESEARCH.md
@.planning/phases/04-nl-mapping-engine/04-01-SUMMARY.md
@packages/ups-mcp/src/generated/shipping.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logistics filter library for Jinja2</name>
  <files>
    - src/orchestrator/filters/__init__.py
    - src/orchestrator/filters/logistics.py
  </files>
  <action>
Create the Jinja2 logistics filter library referenced in CLAUDE.md.

**Package structure:**
```
src/orchestrator/filters/
  __init__.py
  logistics.py
```

**In logistics.py, implement filters from CLAUDE.md:**

1. `truncate_address(value: str, max_length: int = 35) -> str`:
   - Truncate to max_length without cutting words
   - If len(value) <= max_length, return as-is
   - Otherwise, find last space before max_length and truncate there
   - Strip trailing whitespace

2. `format_us_zip(value: str) -> str`:
   - Extract digits only
   - If 5 digits, return as-is
   - If 9 digits, format as "XXXXX-XXXX"
   - If other length, return first 5 digits or padded

3. `round_weight(value: float, decimals: int = 1) -> float`:
   - Round to specified decimal places
   - Ensure minimum 0.1 (UPS minimum weight)

4. `convert_weight(value: float, from_unit: str, to_unit: str) -> float`:
   - Support: g, kg, oz, lbs
   - Conversion factors:
     - 1 kg = 2.20462 lbs
     - 1 oz = 0.0625 lbs
     - 1 g = 0.00220462 lbs
   - Raise ValueError for unsupported units

5. `lookup_service_code(value: str) -> str`:
   - Use SERVICE_ALIASES from intent module
   - Return UPS code (e.g., "ground" -> "03")
   - Pass through if already a code

6. `to_ups_date(value: str | datetime) -> str`:
   - Convert to UPS format: YYYYMMDD
   - Parse various input formats using dateutil

7. `to_ups_phone(value: str) -> str`:
   - Strip all non-digit characters
   - Remove leading 1 if 11 digits
   - Return 10-digit phone or raise ValueError

8. `default_value(value: Any, default: Any) -> Any`:
   - Return default if value is None, empty string, or NaN
   - Otherwise return value

9. `split_name(value: str, part: str) -> str`:
   - part="first": Return first word
   - part="last": Return last word
   - part="all": Return as-is

**Create get_logistics_environment() -> jinja2.Environment:**
- Create SandboxedEnvironment (from jinja2.sandbox)
- Register all filters above
- Set autoescape=False (JSON output)
- Return configured environment

**Export LOGISTICS_FILTERS dict mapping filter names to functions.**
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.filters.logistics import get_logistics_environment, truncate_address, format_us_zip
env = get_logistics_environment()
assert truncate_address('123 Main Street Suite 400', 20) == '123 Main Street'
assert format_us_zip('900011234') == '90001-1234'
print('Logistics filters work')
"
```
  </verify>
  <done>All 9 logistics filters implemented and registered in SandboxedEnvironment; get_logistics_environment() returns configured env</done>
</task>

<task type="auto">
  <name>Task 2: Create mapping models and template generator</name>
  <files>
    - src/orchestrator/models/mapping.py
    - src/orchestrator/models/__init__.py
    - src/orchestrator/nl_engine/mapping_generator.py
    - src/orchestrator/nl_engine/__init__.py
  </files>
  <action>
Create mapping models and the template generator.

**In mapping.py, create:**

1. `FieldMapping` - Pydantic model for single field mapping:
   - source_column: str  # Column from source data
   - target_path: str    # JSONPath in UPS payload (e.g., "ShipTo.Name")
   - transformation: Optional[str] = None  # Jinja2 filter expression
   - default_value: Optional[Any] = None   # Default if source is null

2. `MappingTemplate` - Pydantic model for complete template:
   - name: str  # Template name for saving
   - source_schema_hash: str  # Hash of source column names for matching
   - mappings: list[FieldMapping]
   - missing_required: list[str] = []  # Required UPS fields not mapped
   - jinja_template: Optional[str] = None  # Compiled Jinja2 template string

3. `UPSTargetField` - Pydantic model for UPS schema field info:
   - path: str  # e.g., "ShipTo.Name"
   - type: str  # e.g., "string"
   - required: bool
   - max_length: Optional[int] = None
   - description: str = ""

**In mapping_generator.py, implement:**

1. `UPS_REQUIRED_FIELDS: list[UPSTargetField]` - Key UPS fields for MVP:
   - ShipTo.Name (string, max 35, required)
   - ShipTo.Address.AddressLine (array of strings, max 35 each, required)
   - ShipTo.Address.City (string, max 30, required)
   - ShipTo.Address.StateProvinceCode (string, max 5, required for US)
   - ShipTo.Address.PostalCode (string, max 9, required for US)
   - ShipTo.Address.CountryCode (string, 2 chars, required)
   - ShipTo.Phone.Number (string, 10-15 chars, optional)
   - Package.PackageWeight.Weight (number, required)

2. `suggest_mappings(source_columns: list[str], example_row: dict | None = None) -> list[FieldMapping]`:
   - Use Claude structured outputs to suggest mappings
   - System prompt: "Suggest likely column mappings. DO NOT auto-apply without user confirmation."
   - Return list of suggested FieldMapping objects
   - Per CONTEXT.md: These are SUGGESTIONS only, user must confirm

3. `generate_mapping_template(source_schema: list[ColumnInfo], user_mappings: list[FieldMapping], template_name: str = "default") -> MappingTemplate`:
   - Compute schema_hash from sorted column names
   - Check which UPS_REQUIRED_FIELDS are not mapped
   - Generate Jinja2 template string from mappings:
     ```jinja2
     {
       "ShipTo": {
         "Name": "{{ source_col | truncate_address(35) }}",
         ...
       }
     }
     ```
   - Validate template compiles with get_logistics_environment()
   - Return MappingTemplate with jinja_template populated

4. `compute_schema_hash(columns: list[str]) -> str`:
   - Sort column names
   - JSON encode
   - SHA256 hash, return first 16 chars

5. `render_template(template: MappingTemplate, row_data: dict) -> dict`:
   - Get logistics environment
   - Compile and render template with row_data
   - Parse JSON result
   - Return dict

**Error handling:**
- MappingGenerationError for template compilation failures
- Include source column and target path in error context
  </action>
  <verify>
```bash
python -c "
from src.orchestrator.nl_engine.mapping_generator import generate_mapping_template, compute_schema_hash
from src.orchestrator.models.mapping import FieldMapping
from src.orchestrator.models.filter import ColumnInfo

# Test schema hash
hash_result = compute_schema_hash(['name', 'city', 'state'])
print(f'Schema hash: {hash_result}')

# Test template generation with simple mapping
mappings = [
    FieldMapping(source_column='name', target_path='ShipTo.Name'),
    FieldMapping(source_column='city', target_path='ShipTo.Address.City'),
]
schema = [ColumnInfo(name='name', type='string'), ColumnInfo(name='city', type='string')]
template = generate_mapping_template(schema, mappings)
print(f'Template generated with {len(template.mappings)} mappings')
"
```
  </verify>
  <done>FieldMapping and MappingTemplate models exist; generate_mapping_template creates Jinja2 template from user-provided mappings; compute_schema_hash works</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for mapping generation</name>
  <files>
    - tests/orchestrator/test_mapping_generator.py
    - tests/orchestrator/test_logistics_filters.py
  </files>
  <action>
Create comprehensive tests for mapping generation and logistics filters.

**test_logistics_filters.py:**

1. `TestTruncateAddress`:
   - test_short_string_unchanged
   - test_truncate_at_word_boundary
   - test_single_long_word -> truncates at exact length
   - test_trailing_space_stripped

2. `TestFormatUsZip`:
   - test_five_digit_unchanged
   - test_nine_digit_formatted -> "90001-1234"
   - test_strips_non_digits
   - test_short_zip_padded

3. `TestConvertWeight`:
   - test_kg_to_lbs
   - test_oz_to_lbs
   - test_g_to_lbs
   - test_lbs_to_kg
   - test_unsupported_unit_raises

4. `TestToUpsPhone`:
   - test_ten_digit_unchanged
   - test_strips_formatting -> "(555) 123-4567" -> "5551234567"
   - test_removes_leading_one
   - test_invalid_length_raises

5. `TestSplitName`:
   - test_first_name
   - test_last_name
   - test_single_name_returns_same

**test_mapping_generator.py:**

1. `TestSchemaHash`:
   - test_deterministic -> same columns = same hash
   - test_order_independent -> ['a','b'] == ['b','a'] hash
   - test_different_columns_different_hash

2. `TestFieldMapping`:
   - test_minimal_mapping
   - test_mapping_with_transformation
   - test_mapping_with_default

3. `TestMappingTemplate`:
   - test_template_with_mappings
   - test_missing_required_detected
   - test_jinja_template_populated

4. `TestGenerateMappingTemplate`:
   - test_simple_mapping_generates_template
   - test_template_compiles_in_environment
   - test_missing_required_fields_listed

5. `TestRenderTemplate`:
   - test_render_with_simple_data
   - test_render_applies_filters
   - test_render_uses_defaults_for_null

Use pytest fixtures for common schema/mapping setups.
  </action>
  <verify>
```bash
cd /Users/matthewhans/Desktop/Programming/ShipAgent && python -m pytest tests/orchestrator/test_logistics_filters.py tests/orchestrator/test_mapping_generator.py -v
```
  </verify>
  <done>All tests pass for logistics filters and mapping generator; no API calls required for unit tests</done>
</task>

</tasks>

<verification>
1. `python -c "from src.orchestrator.filters.logistics import get_logistics_environment"` succeeds
2. `python -c "from src.orchestrator.nl_engine.mapping_generator import generate_mapping_template"` succeeds
3. `pytest tests/orchestrator/test_logistics_filters.py tests/orchestrator/test_mapping_generator.py -v` passes
4. All 9 logistics filters from CLAUDE.md implemented
5. Jinja2 templates use SandboxedEnvironment for security
</verification>

<success_criteria>
1. All 9 logistics filters implemented (truncate_address, format_us_zip, round_weight, convert_weight, lookup_service_code, to_ups_date, to_ups_phone, default_value, split_name)
2. FieldMapping and MappingTemplate Pydantic models capture mapping structure
3. generate_mapping_template creates valid Jinja2 templates from user mappings
4. compute_schema_hash produces deterministic, order-independent hashes
5. render_template correctly applies filters and defaults
6. Unit tests pass (20+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/04-nl-mapping-engine/04-03-SUMMARY.md`
</output>
