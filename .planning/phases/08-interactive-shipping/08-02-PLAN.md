---
phase: 08-interactive-shipping
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/routes/interactive.py
  - src/api/schemas_interactive.py
  - src/api/main.py
autonomous: true

must_haves:
  truths:
    - "Frontend can submit completed form data via POST /api/v1/interactive/submit"
    - "Form submission creates a single-row job and triggers preview via BatchEngine"
    - "Preview result is returned as JSON response (not SSE) since this is a deterministic POST"
    - "Endpoint validates all required shipping fields before creating job"
  artifacts:
    - path: "src/api/routes/interactive.py"
      provides: "POST /interactive/submit endpoint for form submission"
      min_lines: 40
    - path: "src/api/schemas_interactive.py"
      provides: "Pydantic request/response schemas for interactive shipping"
      min_lines: 20
    - path: "src/api/main.py"
      provides: "Router registration for interactive endpoint"
      contains: "interactive"
  key_links:
    - from: "src/api/routes/interactive.py"
      to: "src/services/interactive_shipping.py"
      via: "import create_interactive_job, build_order_data_from_form"
      pattern: "create_interactive_job"
    - from: "src/api/routes/interactive.py"
      to: "src/services/batch_engine.py"
      via: "BatchEngine.preview() for single-row preview"
      pattern: "BatchEngine"
    - from: "src/api/main.py"
      to: "src/api/routes/interactive.py"
      via: "app.include_router(interactive.router)"
      pattern: "interactive"
---

<objective>
Create a lightweight REST endpoint for interactive form submission. When the frontend renders the elicitation form and the user fills it out, the form data is POSTed directly to this endpoint (bypassing the agent, since form-to-job is deterministic). The endpoint creates a single-row job, runs preview, and returns the preview result.

Purpose: Decouple the deterministic form submission from the LLM agent loop. The form data is structured and validated via Pydantic -- no LLM interpretation needed. This saves tokens and reduces latency.

Output: `src/api/routes/interactive.py`, `src/api/schemas_interactive.py`, updated `src/api/main.py`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/api/main.py
@src/api/routes/conversations.py
@src/api/schemas.py
@src/api/schemas_conversations.py
@src/services/batch_engine.py
@src/services/ups_payload_builder.py
@src/db/models.py
@src/services/job_service.py
@.planning/phases/08-interactive-shipping/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for interactive shipping</name>
  <files>src/api/schemas_interactive.py</files>
  <action>
Create `src/api/schemas_interactive.py` with Pydantic models:

1. **`InteractiveSubmitRequest`** (BaseModel):
   - `ship_to_name`: str (required)
   - `ship_to_address1`: str (required)
   - `ship_to_city`: str (required)
   - `ship_to_state`: str (required, max_length=2 via Field)
   - `ship_to_postal_code`: str (required)
   - `weight`: float (required, gt=0, le=150 via Field)
   - `service_code`: str = "03" (default UPS Ground)
   - `ship_to_country`: str = "US"
   - `ship_to_address2`: str | None = None
   - `ship_to_phone`: str | None = None
   - `ship_to_company`: str | None = None
   - `length`: float | None = None
   - `width`: float | None = None
   - `height`: float | None = None
   - `packaging_type`: str = "02"
   - `command`: str = "Interactive shipment" (original command text for job naming)
   - `session_id`: str | None = None (optional conversation session ID for SSE event routing)

2. **`InteractiveSubmitResponse`** (BaseModel):
   - `job_id`: str
   - `status`: str (e.g. "preview_ready")
   - `total_estimated_cost_cents`: int
   - `preview_rows`: list[dict] (single-element list with the one row's preview)
   - `total_rows`: int = 1

Include proper docstrings. Use `from pydantic import BaseModel, Field`.
  </action>
  <verify>
Run: `python -c "
from src.api.schemas_interactive import InteractiveSubmitRequest, InteractiveSubmitResponse
req = InteractiveSubmitRequest(
    ship_to_name='John Smith',
    ship_to_address1='123 Main St',
    ship_to_city='New York',
    ship_to_state='NY',
    ship_to_postal_code='10001',
    weight=5.0,
)
assert req.service_code == '03'
assert req.ship_to_country == 'US'
print('Schemas OK')
"` -- should print 'Schemas OK'.
  </verify>
  <done>Pydantic schemas exist for interactive form submission with proper validation constraints (weight range, state max_length, sensible defaults).</done>
</task>

<task type="auto">
  <name>Task 2: Create interactive endpoint and register router</name>
  <files>src/api/routes/interactive.py, src/api/main.py</files>
  <action>
**Create `src/api/routes/interactive.py`**:

1. Create an APIRouter with prefix="/interactive" and tags=["interactive"].

2. **`POST /submit`** endpoint:
   - Accepts `InteractiveSubmitRequest` body
   - Returns `InteractiveSubmitResponse`
   - Implementation:
     a. Convert request to form_data dict: `form_data = request.model_dump(exclude_none=True, exclude={"command", "session_id"})`
     b. Call `create_interactive_job(form_data, request.command)` from `src.services.interactive_shipping` to create Job + single JobRow. This returns `(job_id, db_rows)`.
     c. Run preview: Create BatchEngine with UPS client (same pattern as `_run_batch_preview` in tools_v2.py):
        ```python
        from src.orchestrator.agent.tools_v2 import _get_ups_client
        from src.services.batch_engine import BatchEngine
        from src.services.ups_payload_builder import build_shipper_from_env

        account_number = os.environ.get("UPS_ACCOUNT_NUMBER", "")
        shipper = build_shipper_from_env()
        ups = await _get_ups_client()

        with get_db_context() as db:
            engine = BatchEngine(ups_service=ups, db_session=db, account_number=account_number)
            svc = JobService(db)
            rows = svc.get_rows(job_id)
            result = await engine.preview(job_id=job_id, rows=rows, shipper=shipper)
        ```
     d. If `session_id` is provided, emit `preview_ready` SSE event to that session's queue (import `_get_event_queue` from conversations route or use the bridge). This is optional and best-effort -- the HTTP response always returns the preview data regardless.
     e. Return `InteractiveSubmitResponse` with job_id, status="preview_ready", total_estimated_cost_cents, preview_rows, total_rows=1
   - Error handling:
     - `ValueError` from `build_order_data_from_form` -> HTTP 422 with detail
     - `UPSServiceError` from preview -> HTTP 502 with error details
     - Generic exceptions -> HTTP 500

3. Import patterns to follow:
   - `import os, logging` at top
   - `from fastapi import APIRouter, HTTPException`
   - `from src.api.schemas_interactive import InteractiveSubmitRequest, InteractiveSubmitResponse`
   - `from src.services.interactive_shipping import create_interactive_job`
   - `from src.db.connection import get_db_context`
   - `from src.services.job_service import JobService`
   - Lazy imports for BatchEngine/UPS client inside the handler (same pattern as tools_v2.py)

**Update `src/api/main.py`**:

1. Add import: In the `from src.api.routes import (...)` block, add `interactive` to the imported modules.
2. Add router registration: `app.include_router(interactive.router, prefix="/api/v1")` alongside the other router registrations.

Also create `src/api/routes/__init__.py` entry if needed -- check if existing `__init__.py` needs `interactive` added. The existing main.py imports routes as `from src.api.routes import conversations, data_sources, jobs, ...` so the module just needs to exist.
  </action>
  <verify>
Run: `python -c "
from src.api.routes.interactive import router
routes = [r.path for r in router.routes]
print('Routes:', routes)
assert any('/submit' in r for r in routes), 'Missing /submit route'
print('Router OK')
"` -- should show /submit route.

Run: `python -c "
from src.api.main import app
route_paths = [r.path for r in app.routes]
interactive_routes = [p for p in route_paths if 'interactive' in p]
print('Interactive routes:', interactive_routes)
assert len(interactive_routes) > 0, 'Interactive router not registered'
print('Main app OK')
"` -- should show /api/v1/interactive/submit registered.
  </verify>
  <done>POST /api/v1/interactive/submit endpoint exists, accepts structured form data, creates single-row job, runs UPS rate preview via BatchEngine, and returns preview result. Router registered in main.py.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.api.schemas_interactive import InteractiveSubmitRequest; print('Schemas OK')"` succeeds
2. `python -c "from src.api.routes.interactive import router; print('Router OK')"` succeeds
3. `python -c "from src.api.main import app; paths = [r.path for r in app.routes]; assert any('interactive' in p for p in paths); print('Registered OK')"` succeeds
4. Endpoint follows existing patterns: lazy UPS client import, get_db_context, BatchEngine instantiation
5. No new dependencies introduced
</verification>

<success_criteria>
- POST /api/v1/interactive/submit endpoint accepts InteractiveSubmitRequest, returns preview data
- Pydantic validates all required fields (name, address, city, state, zip, weight)
- Single-row job created via existing Job + JobRow models
- Preview runs through existing BatchEngine.preview() -- no separate UPS call path
- Router registered in main.py alongside existing routers
</success_criteria>

<output>
After completion, create `.planning/phases/08-interactive-shipping/08-02-SUMMARY.md`
</output>
