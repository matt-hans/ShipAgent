---
phase: 08-interactive-shipping
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/api/routes/interactive.py
  - src/services/command_processor.py
  - src/api/main.py
autonomous: true

must_haves:
  truths:
    - "User can POST a NL command and receive an elicitation response with JSON Schema for missing fields"
    - "User can POST filled form data and receive a preview with cost estimate"
    - "User can start interactive flow without typing a command (button click starts with full form)"
    - "Interactive shipments create single-row Jobs through the existing BatchEngine pipeline"
    - "Existing batch command flow is completely unaffected"
  artifacts:
    - path: "src/api/routes/interactive.py"
      provides: "Interactive shipping API endpoints"
      exports: ["router"]
    - path: "src/services/command_processor.py"
      provides: "Extended with _process_interactive() method"
      contains: "_process_interactive"
    - path: "src/api/main.py"
      provides: "Interactive router registered"
      contains: "interactive"
  key_links:
    - from: "src/api/routes/interactive.py"
      to: "src/services/interactive_shipping.py"
      via: "import generate_shipping_form_schema, create_interactive_job_row"
      pattern: "from src.services.interactive_shipping import"
    - from: "src/api/routes/interactive.py"
      to: "src/services/command_processor.py"
      via: "CommandProcessor for intent parsing"
      pattern: "CommandProcessor"
    - from: "src/api/routes/interactive.py"
      to: "src/services/batch_engine.py"
      via: "BatchEngine.preview() for single-row rate quote"
      pattern: "BatchEngine"
---

<objective>
Create the API endpoints and backend routing for interactive shipping, connecting the schema generator (Plan 01) to the frontend (Plan 03).

Purpose: This plan wires up the interactive flow: NL command -> intent parse -> schema generation -> form submission -> single-row job creation -> preview via BatchEngine. It adds new API endpoints in a separate router module and extends CommandProcessor with an interactive path.

Output: New `src/api/routes/interactive.py` with `/api/v1/interactive/start` and `/api/v1/interactive/submit` endpoints. Extended CommandProcessor with `_process_interactive()`. Updated `main.py` to register the interactive router.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-interactive-shipping/08-RESEARCH.md
@.planning/phases/08-interactive-shipping/08-01-SUMMARY.md

@src/api/routes/commands.py
@src/api/main.py
@src/services/command_processor.py
@src/services/interactive_shipping.py
@src/services/batch_engine.py
@src/services/ups_payload_builder.py
@src/services/ups_service.py
@src/api/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interactive shipping API routes</name>
  <files>src/api/routes/interactive.py, src/api/main.py</files>
  <action>
**Create `src/api/routes/interactive.py`:**

This module provides two endpoints for the interactive shipping flow:

1. **`POST /api/v1/interactive/start`** - Start interactive shipping flow
   - Request body: `CommandSubmit` (existing schema, has `command: str` field). Also accept a query param `?mode=button` for button-initiated flow (no NL command).
   - For button mode (no command / empty command / `mode=button` query param):
     - Call `generate_shipping_form_schema({})` with empty dict to get full form
     - Return `ElicitationResponse` with full schema, empty initial_data, message "Fill in the shipment details below:"
   - For NL command mode:
     - Call `parse_intent(command)` to extract intent
     - If `intent.is_interactive` is True OR if no data source is active (detect via DataSourceService.get_instance().get_source_info() is None and no Shopify connected):
       - Use `initial_data` from the intent (the LLM extracts partial data like name, address, weight from the NL command)
       - Call `generate_shipping_form_schema(initial_data or {})`
       - Return `ElicitationResponse` with schema, initial_data, message
     - If intent is NOT interactive (references a data source):
       - Return 400 error: "This command references a data source. Use the standard command endpoint instead."
   - On parse error: return 400 with error message

   IMPORTANT: The intent parser's tool definition must be updated to include `is_interactive` and `initial_data` fields. However, to avoid modifying the LLM tool schema in this plan (which could break existing parsing), use a SIMPLER approach:

   Instead of relying on the LLM to set `is_interactive`, detect it deterministically:
   - If the intent has NO `data_source` AND NO `filter_criteria`, it's likely interactive
   - If the command contains direct shipping indicators ("ship a", "send a", "ship to", "send to", "mail a", "mail to") without file/source references, treat as interactive
   - Extract `initial_data` by calling `parse_intent()` and reading `package_defaults` (already extracts weight) and parsing the command for address components

   Actually, the CLEANEST approach given the existing `parse_intent()`: Call `parse_intent()` normally. If it returns a ShippingIntent with `data_source=None` and the command doesn't reference a connected source, treat it as interactive. For initial_data extraction, create a lightweight `extract_shipping_fields(command: str) -> dict` function in `interactive_shipping.py` that uses regex patterns to pull:
   - Weight: matches like "5lb", "5 lb", "5 lbs", "5 pound", "5 pounds"
   - Name: text after "to" before address indicators like "at", "in", numbers
   - Address: text after "at" containing street indicators
   - City/State/ZIP: common patterns

   This keeps it deterministic (no extra LLM calls).

2. **`POST /api/v1/interactive/submit`** - Submit filled form data
   - Request body: `InteractiveShipmentRequest` (has `form_data: dict`, `job_id: str | None`)
   - Validate form_data has all required fields (check against UPS_REQUIRED_FIELDS keys)
   - Call `create_interactive_job_row(db, form_data)` to create Job + JobRow
   - Rate the single row via BatchEngine.preview():
     - Create UPSService and BatchEngine same as `CommandProcessor._rate_job_rows()`
     - Call `engine.preview(job_id, [job_row], shipper, service_code)`
     - Update the row's cost_cents from preview result
   - Set job.total_rows = 1
   - Commit and return the job_id + preview data (reuse `BatchPreviewResponse`)
   - This means the frontend gets back a standard preview response and can show PreviewCard

   Error handling:
   - Missing required fields: 422 with list of missing fields
   - UPS rating failure: Return preview with $0 estimate and warning (non-blocking)

**Update `src/api/main.py`:**

Import and register the interactive router:
```python
from src.api.routes.interactive import router as interactive_router
app.include_router(interactive_router, prefix="/api/v1")
```

Add it alongside the existing router registrations.
  </action>
  <verify>
    Run: `python -c "from src.api.routes.interactive import router; print([r.path for r in router.routes])"` - Shows the two endpoint paths.
    Run: `python -c "from src.api.main import app; routes = [r.path for r in app.routes]; assert '/api/v1/interactive/start' in routes or any('interactive' in str(r) for r in routes)"` - Interactive routes registered.
  </verify>
  <done>
    - POST /api/v1/interactive/start returns ElicitationResponse with JSON Schema
    - POST /api/v1/interactive/submit creates Job + JobRow and returns preview
    - Interactive router registered in main.py
    - No existing endpoints or routes affected
  </done>
</task>

<task type="auto">
  <name>Task 2: Add field extraction helper and interactive routing in CommandProcessor</name>
  <files>src/services/interactive_shipping.py, src/services/command_processor.py</files>
  <action>
**In `src/services/interactive_shipping.py`, add `extract_shipping_fields(command: str) -> dict[str, Any]`:**

A deterministic (no LLM) function that extracts shipping fields from a NL command using regex patterns:

1. **Weight extraction**: Match patterns like `(\d+\.?\d*)\s*(lb|lbs|pound|pounds|kg|kgs)` in the command. Convert kg to lbs (* 2.205). Store as float in `weight` key.

2. **Service code extraction**: Check for service keywords using the existing `SERVICE_ALIASES` dict from `src/orchestrator/models/intent.py`. Lowercase the command, check each alias, set `service_code` to the matching ServiceCode value string.

3. **Name extraction**: Look for pattern "to ([A-Z][a-z]+ [A-Z][a-z]+)" (capitalized first+last name after "to"). Store in `ship_to_name`. Be careful not to match city names (stop at "at", "in", digits, commas).

4. **Address extraction**: Look for pattern "at (\d+ .+?)(?:,|\s+(?:in|near))" for street address. Store in `ship_to_address1`.

5. **City/State/ZIP**: Look for common patterns:
   - State: two-letter uppercase code or full state name (map to 2-letter code)
   - ZIP: 5-digit or ZIP+4 pattern
   - City: text between address and state, or after "in"

Return a dict with only the fields that were successfully extracted (do NOT include None values). This ensures `generate_shipping_form_schema()` only pre-fills what was actually found.

This function is best-effort. Missing extractions are fine -- the form will ask the user for them. Over-extraction (wrong values) is handled by the form showing defaults the user can edit.

**In `src/services/command_processor.py`, add interactive detection to `_process_internal()`:**

After the existing data source check and before the Shopify fallback, add a new branch:

```python
# Check if this is an interactive shipping command (no data source needed)
# Detect by: no local source active AND intent has no data_source reference
# This is handled by the /api/v1/interactive/start endpoint instead
# CommandProcessor._process_internal() does NOT need modification for interactive mode
# The interactive flow uses separate API endpoints (/interactive/start, /interactive/submit)
```

Actually, on reflection, the CommandProcessor does NOT need modification. The interactive flow uses entirely separate endpoints (`/interactive/start` and `/interactive/submit`) that bypass CommandProcessor entirely. The CommandProcessor is only for batch commands that need data source filtering.

Instead, update the `_process_internal` error message when no data source is connected (the Shopify fallback path) to suggest using interactive mode:

In the existing error at line ~993-998 where it sets error_message for no Shopify connection, update to:
```python
job.error_message = (
    "No data source connected. Please import a CSV/Excel file, "
    "connect Shopify in Data Sources, or use Interactive Ship mode "
    "to create a single shipment."
)
```

This is a one-line change that improves the UX when users try batch commands without a data source.
  </action>
  <verify>
    Run: `python -c "from src.services.interactive_shipping import extract_shipping_fields; result = extract_shipping_fields('Ship a 5lb box to John Smith at 123 Main St, New York NY 10001'); print(result); assert result.get('weight') == 5.0; assert result.get('ship_to_name') == 'John Smith'"` - Extracts weight and name.
    Run: `python -c "from src.services.interactive_shipping import extract_shipping_fields; result = extract_shipping_fields('Send a package to Jane Doe using Ground'); print(result); assert 'service_code' in result"` - Extracts service code.
  </verify>
  <done>
    - extract_shipping_fields() extracts weight, name, address, city, state, zip, service from NL commands
    - Function is purely regex-based, no LLM calls (deterministic)
    - CommandProcessor error message updated to mention interactive mode
    - Interactive flow uses separate API endpoints, not CommandProcessor
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.api.routes.interactive import router"` - Import succeeds
2. `python -c "from src.services.interactive_shipping import extract_shipping_fields"` - Import succeeds
3. `pytest tests/ -k "command_processor" --no-header -q 2>/dev/null | tail -3` - Existing tests still pass
4. Start backend and test: `curl -X POST http://localhost:8000/api/v1/interactive/start -H 'Content-Type: application/json' -d '{"command": "Ship a 5lb box to John Smith at 123 Main St, New York NY 10001"}'` - Returns elicitation response with schema
</verification>

<success_criteria>
- /api/v1/interactive/start returns ElicitationResponse with flat JSON Schema
- /api/v1/interactive/submit creates single-row Job and returns BatchPreviewResponse
- Button-initiated flow (no command) returns full form schema
- NL-initiated flow pre-fills extracted fields in schema defaults
- extract_shipping_fields() is deterministic (no LLM)
- Existing batch flow completely unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/08-interactive-shipping/08-02-SUMMARY.md`
</output>
