---
phase: 08-interactive-shipping
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/api/routes/interactive.py
  - src/services/interactive_shipping.py
  - src/services/command_processor.py
  - src/api/main.py
autonomous: true

must_haves:
  truths:
    - "User can POST a NL command and receive an elicitation response with JSON Schema for missing fields"
    - "User receives a cost estimate preview after submitting the interactive shipment form"
    - "User can start interactive flow without typing a command (button click starts with full form)"
    - "User can confirm the interactive preview and the shipment executes through the existing confirm endpoint"
    - "Existing batch command flow is completely unaffected"
  artifacts:
    - path: "src/api/routes/interactive.py"
      provides: "Interactive shipping API endpoints"
      exports: ["router"]
    - path: "src/services/interactive_shipping.py"
      provides: "Extended with extract_shipping_fields() deterministic field extractor"
      contains: "extract_shipping_fields"
    - path: "src/api/main.py"
      provides: "Interactive router registered"
      contains: "interactive"
  key_links:
    - from: "src/api/routes/interactive.py"
      to: "src/services/interactive_shipping.py"
      via: "import generate_shipping_form_schema, extract_shipping_fields, create_interactive_job_row"
      pattern: "from src.services.interactive_shipping import"
    - from: "src/api/routes/interactive.py"
      to: "src/services/batch_engine.py"
      via: "BatchEngine.preview() for single-row rate quote"
      pattern: "BatchEngine"
    - from: "src/api/routes/interactive.py"
      to: "src/api/routes/preview.py"
      via: "Job created by interactive submit is confirmed via existing POST /jobs/{id}/confirm endpoint"
      pattern: "Job.*status.*pending"
---

<objective>
Create the API endpoints and backend routing for interactive shipping, connecting the schema generator (Plan 01) to the frontend (Plan 03).

Purpose: This plan wires up the interactive flow: NL command -> deterministic field extraction -> schema generation -> form submission -> single-row job creation -> preview via BatchEngine. The job created by `/interactive/submit` is in `pending` status, which means the existing `POST /jobs/{id}/confirm` endpoint handles the confirm->execute step with no modifications needed.

Output: New `src/api/routes/interactive.py` with `/api/v1/interactive/start` and `/api/v1/interactive/submit` endpoints. New `extract_shipping_fields()` in `interactive_shipping.py`. Updated `main.py` to register the interactive router. Minor CommandProcessor error message update.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-interactive-shipping/08-RESEARCH.md
@.planning/phases/08-interactive-shipping/08-01-SUMMARY.md

@src/api/routes/commands.py
@src/api/routes/preview.py
@src/api/main.py
@src/services/command_processor.py
@src/services/interactive_shipping.py
@src/services/batch_engine.py
@src/services/ups_payload_builder.py
@src/services/ups_service.py
@src/api/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create interactive shipping API routes</name>
  <files>src/api/routes/interactive.py, src/api/main.py</files>
  <action>
**Create `src/api/routes/interactive.py`:**

This module provides two endpoints for the interactive shipping flow. Both endpoints are fully deterministic -- no LLM calls.

1. **`POST /api/v1/interactive/start`** - Start interactive shipping flow
   - Request body: `CommandSubmit` (existing schema, has `command: str` field). Also accept a query param `?mode=button` for button-initiated flow.
   - For **button mode** (`mode=button` query param OR empty/missing command):
     - Call `generate_shipping_form_schema({})` with empty dict to get full form
     - Return `ElicitationResponse` with full schema, empty initial_data, message "Fill in the shipment details below:"
   - For **NL command mode** (non-empty command without `mode=button`):
     - Call `extract_shipping_fields(command)` (imported from `src.services.interactive_shipping`, built in Task 2) to deterministically extract partial shipping data from the NL text
     - Call `generate_shipping_form_schema(extracted_fields)` to build the schema with pre-filled defaults
     - Return `ElicitationResponse` with schema, extracted_fields as initial_data, and the message from the generator
   - On error: return 400 with error message

   IMPORTANT: Do NOT call `parse_intent()` or any LLM-based function in this endpoint. The interactive start path is entirely deterministic per requirement INT-07. Field extraction uses regex patterns (Task 2), not the NL engine.

2. **`POST /api/v1/interactive/submit`** - Submit filled form data and get preview
   - Request body: `InteractiveShipmentRequest` (has `form_data: dict`, `job_id: str | None`)
   - Validate form_data has all required fields by checking against `UPS_REQUIRED_FIELDS` keys. Return 422 with list of missing fields if any are absent.
   - Call `create_interactive_job_row(db, form_data)` to create Job (status=pending) + single JobRow
   - Rate the single row via BatchEngine.preview():
     - Create UPSService and BatchEngine same as `CommandProcessor._rate_job_rows()` pattern
     - Call `engine.preview(job_id, [job_row], shipper, service_code)` where shipper comes from `build_shipper_from_env()`
     - Update the row's cost_cents from preview result
   - Set job.total_rows = 1, commit
   - Return `{"job_id": job.id, "preview": BatchPreviewResponse}` -- the frontend receives a standard preview response and shows PreviewCard
   - After PreviewCard confirmation, the EXISTING `POST /jobs/{id}/confirm` endpoint (in `src/api/routes/preview.py`) handles execution because the job is in `pending` status. No modifications to the confirm endpoint are needed.
   - Error handling for UPS rating failure: Return preview with $0 estimate and a warning message (non-blocking, user can still confirm)

**Update `src/api/main.py`:**

Import and register the interactive router alongside existing routers:
```python
from src.api.routes.interactive import router as interactive_router
app.include_router(interactive_router, prefix="/api/v1")
```
  </action>
  <verify>
    Run: `python -c "from src.api.routes.interactive import router; print([r.path for r in router.routes])"` - Shows the two endpoint paths.
    Run: `python -c "from src.api.main import app; routes = [r.path for r in app.routes]; assert any('interactive' in str(r) for r in routes)"` - Interactive routes registered.
  </verify>
  <done>
    - POST /api/v1/interactive/start returns ElicitationResponse with JSON Schema (no LLM calls)
    - POST /api/v1/interactive/submit creates Job (pending) + JobRow and returns preview
    - Job is in pending status so existing POST /jobs/{id}/confirm handles execution
    - Interactive router registered in main.py
    - No existing endpoints or routes affected
  </done>
</task>

<task type="auto">
  <name>Task 2: Add deterministic field extraction helper and update CommandProcessor error message</name>
  <files>src/services/interactive_shipping.py, src/services/command_processor.py</files>
  <action>
**In `src/services/interactive_shipping.py`, add `extract_shipping_fields(command: str) -> dict[str, Any]`:**

A deterministic (no LLM) function that extracts shipping fields from a NL command using regex patterns. This is called by the `/interactive/start` endpoint (Task 1) for NL command mode.

1. **Weight extraction**: Match patterns like `(\d+\.?\d*)\s*(lb|lbs|pound|pounds|kg|kgs)` in the command. Convert kg to lbs (* 2.205). Store as float in `weight` key.

2. **Service code extraction**: Match service keywords against known UPS service names:
   - "ground" -> "03"
   - "2nd day" / "2 day" / "second day" -> "02"
   - "next day" / "overnight" -> "01"
   - "3 day" / "three day" / "3 day select" -> "12"
   Store in `service_code` key.

3. **Name extraction**: Look for pattern "to ([A-Z][a-z]+ [A-Z][a-z]+)" (capitalized first+last name after "to"). Store in `ship_to_name`. Stop matching at "at", "in", digits, commas to avoid capturing city names.

4. **Address extraction**: Look for pattern "at (\d+ .+?)(?:,|\s+(?:in|near))" for street address. Store in `ship_to_address1`.

5. **City/State/ZIP**: Look for common patterns:
   - State: two-letter uppercase code `\b([A-Z]{2})\b` near a ZIP code
   - ZIP: 5-digit or ZIP+4 pattern `\b(\d{5})(-\d{4})?\b`
   - City: text between address and state, or after "in"

Return a dict with only the fields that were successfully extracted (do NOT include None values). This ensures `generate_shipping_form_schema()` only pre-fills what was actually found.

This function is best-effort. Missing extractions are fine -- the form will ask the user for them. Over-extraction (wrong values) is handled by the form showing defaults the user can edit.

Add `extract_shipping_fields` to the module's `__all__` list.

**In `src/services/command_processor.py`:**

The CommandProcessor does NOT need a `_process_interactive()` method. The interactive flow uses separate API endpoints (`/interactive/start` and `/interactive/submit`) that bypass CommandProcessor entirely.

Make one minor UX improvement: update the error message in `_process_internal()` when no data source is connected (the existing Shopify fallback error path) to mention interactive mode:

```python
job.error_message = (
    "No data source connected. Please import a CSV/Excel file, "
    "connect Shopify in Data Sources, or use Interactive Ship mode "
    "to create a single shipment."
)
```

This is a single string change.
  </action>
  <verify>
    Run: `python -c "from src.services.interactive_shipping import extract_shipping_fields; result = extract_shipping_fields('Ship a 5lb box to John Smith at 123 Main St, New York NY 10001'); print(result); assert result.get('weight') == 5.0; assert result.get('ship_to_name') == 'John Smith'"` - Extracts weight and name.
    Run: `python -c "from src.services.interactive_shipping import extract_shipping_fields; result = extract_shipping_fields('Send a package to Jane Doe using Ground'); print(result); assert 'service_code' in result"` - Extracts service code.
  </verify>
  <done>
    - extract_shipping_fields() extracts weight, name, address, city, state, zip, service from NL commands
    - Function is purely regex-based, no LLM calls (deterministic)
    - CommandProcessor error message updated to mention interactive mode
    - Interactive flow uses separate API endpoints, not CommandProcessor
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.api.routes.interactive import router"` - Import succeeds
2. `python -c "from src.services.interactive_shipping import extract_shipping_fields"` - Import succeeds
3. `pytest tests/ -k "command_processor" --no-header -q 2>/dev/null | tail -3` - Existing tests still pass
4. Start backend and test: `curl -X POST http://localhost:8000/api/v1/interactive/start -H 'Content-Type: application/json' -d '{"command": "Ship a 5lb box to John Smith at 123 Main St, New York NY 10001"}'` - Returns elicitation response with schema
</verification>

<success_criteria>
- /api/v1/interactive/start returns ElicitationResponse with flat JSON Schema
- /api/v1/interactive/submit creates single-row Job (pending status) and returns BatchPreviewResponse
- Interactive job can be confirmed via existing POST /jobs/{id}/confirm endpoint
- Button-initiated flow (no command) returns full form schema
- NL-initiated flow pre-fills extracted fields in schema defaults
- extract_shipping_fields() is deterministic (no LLM)
- Existing batch flow completely unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/08-interactive-shipping/08-02-SUMMARY.md`
</output>
