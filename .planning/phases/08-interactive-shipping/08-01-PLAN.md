---
phase: 08-interactive-shipping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/interactive_shipping.py
  - src/orchestrator/agent/tools_v2.py
  - src/orchestrator/agent/system_prompt.py
autonomous: true

must_haves:
  truths:
    - "Agent detects interactive shipping intent when user says 'ship a box to...' without a data source"
    - "Deterministic schema generator produces flat JSON Schema with only missing fields"
    - "Schema generation uses zero LLM tokens"
    - "Elicitation form schema is emitted as SSE event to frontend"
  artifacts:
    - path: "src/services/interactive_shipping.py"
      provides: "InteractiveShippingService with generate_form_schema() and create_shipment_from_form()"
      min_lines: 120
    - path: "src/orchestrator/agent/tools_v2.py"
      provides: "start_interactive_shipment tool + submit_interactive_form tool definitions and handlers"
      contains: "start_interactive_shipment"
    - path: "src/orchestrator/agent/system_prompt.py"
      provides: "Updated system prompt with interactive shipping workflow instructions"
      contains: "interactive"
  key_links:
    - from: "src/orchestrator/agent/tools_v2.py"
      to: "src/services/interactive_shipping.py"
      via: "import and call generate_form_schema()"
      pattern: "generate_form_schema"
    - from: "src/orchestrator/agent/tools_v2.py"
      to: "EventEmitterBridge"
      via: "_emit_event('elicitation_form', ...)"
      pattern: "elicitation_form"
    - from: "src/services/interactive_shipping.py"
      to: "src/services/ups_payload_builder.py"
      via: "import build_shipment_request, build_shipper_from_env"
      pattern: "build_shipment_request"
---

<objective>
Create the backend core for interactive shipping: a deterministic InteractiveShippingService that generates flat JSON Schema forms for missing UPS fields, and two new tools in tools_v2.py that the agent can call to start interactive flows and process submitted form data.

Purpose: Enable single-shipment creation via conversation without requiring a data source file. The agent detects interactive intent and calls a deterministic tool that emits an elicitation form to the frontend.

Output: `src/services/interactive_shipping.py`, updated `src/orchestrator/agent/tools_v2.py`, updated `src/orchestrator/agent/system_prompt.py`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/orchestrator/agent/tools_v2.py
@src/orchestrator/agent/system_prompt.py
@src/orchestrator/agent/client.py
@src/services/ups_payload_builder.py
@src/services/batch_engine.py
@src/services/job_service.py
@src/db/models.py
@src/services/column_mapping.py
@.planning/phases/08-interactive-shipping/08-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InteractiveShippingService</name>
  <files>src/services/interactive_shipping.py</files>
  <action>
Create `src/services/interactive_shipping.py` with:

1. **Field registry constants** (no LLM, pure Python dicts):

   `REQUIRED_FIELDS` dict mapping field names to JSON Schema property definitions:
   - `ship_to_name`: `{"type": "string", "title": "Recipient Name"}`
   - `ship_to_address1`: `{"type": "string", "title": "Street Address"}`
   - `ship_to_city`: `{"type": "string", "title": "City"}`
   - `ship_to_state`: `{"type": "string", "title": "State", "maxLength": 2}`
   - `ship_to_postal_code`: `{"type": "string", "title": "ZIP Code", "pattern": "^\\d{5}(-\\d{4})?$"}`
   - `weight`: `{"type": "number", "title": "Package Weight (lbs)", "minimum": 0.1, "maximum": 150}`
   - `service_code`: `{"type": "string", "title": "Shipping Service", "oneOf": [{"const": "03", "title": "UPS Ground"}, {"const": "02", "title": "2nd Day Air"}, {"const": "01", "title": "Next Day Air"}, {"const": "12", "title": "3 Day Select"}, {"const": "13", "title": "Next Day Air Saver"}], "default": "03"}`

   `DEFAULT_FIELDS` dict for auto-populated values:
   - `ship_to_country`: `"US"`
   - `packaging_type`: `"02"` (Customer Supplied Package)

   `OPTIONAL_FIELDS` dict:
   - `ship_to_address2`: `{"type": "string", "title": "Address Line 2"}`
   - `ship_to_phone`: `{"type": "string", "title": "Phone Number"}`
   - `ship_to_company`: `{"type": "string", "title": "Company Name"}`
   - `length`: `{"type": "number", "title": "Length (in)", "minimum": 1}`
   - `width`: `{"type": "number", "title": "Width (in)", "minimum": 1}`
   - `height`: `{"type": "number", "title": "Height (in)", "minimum": 1}`

2. **`generate_form_schema(provided_data: dict[str, Any]) -> dict[str, Any]`**:
   - Iterates REQUIRED_FIELDS: if field is missing or empty in `provided_data`, add to `properties` and `required` list
   - Iterates OPTIONAL_FIELDS: if field is missing in `provided_data`, add to `properties` (not required)
   - For fields that ARE in `provided_data`, include them in a `prefilled` dict (separate from schema) so frontend can pre-populate
   - Returns MCP-compliant flat JSON Schema:
     ```python
     {
       "type": "object",
       "properties": {...},  # Only missing/optional fields
       "required": [...],     # Only missing required fields
       "prefilled": {...},    # Fields already extracted from NL
     }
     ```
   - If ALL required fields are present, returns schema with empty `properties` and `required` (signals no form needed)

3. **`build_order_data_from_form(form_data: dict[str, Any]) -> dict[str, Any]`**:
   - Merges form data with DEFAULT_FIELDS
   - Validates all REQUIRED_FIELDS are present (raise ValueError if not)
   - Returns a dict compatible with `build_shipment_request()` from `ups_payload_builder.py`

4. **`create_interactive_job(form_data: dict[str, Any], command: str) -> tuple[str, list]`**:
   - Creates a Job via JobService with name like "Interactive: Ship to {ship_to_name}"
   - Creates a single JobRow with order_data from `build_order_data_from_form(form_data)`
   - Uses `_build_job_row_data` pattern from tools_v2.py (hashlib checksum, row_number=1)
   - Returns (job_id, db_rows) tuple for use with BatchEngine

Include proper docstrings for every function. Include proper type hints. Import from existing modules:
- `from src.services.ups_payload_builder import build_shipment_request, build_shipper_from_env`
- `from src.db.connection import get_db_context`
- `from src.services.job_service import JobService`
  </action>
  <verify>
Run: `python -c "from src.services.interactive_shipping import generate_form_schema, build_order_data_from_form, create_interactive_job, REQUIRED_FIELDS, OPTIONAL_FIELDS; print('OK')"` -- should print OK without errors.

Run: `python -c "
from src.services.interactive_shipping import generate_form_schema
# Test with partial data
schema = generate_form_schema({'ship_to_name': 'John Smith', 'weight': 5.0})
assert 'ship_to_name' not in schema['properties'], 'Provided field should not be in schema'
assert 'ship_to_address1' in schema['properties'], 'Missing required field should be in schema'
assert 'ship_to_name' in schema['prefilled'], 'Provided field should be in prefilled'
assert schema['prefilled']['ship_to_name'] == 'John Smith'
print('Schema generation OK')
"` -- should print 'Schema generation OK'.
  </verify>
  <done>InteractiveShippingService exists with generate_form_schema() that deterministically produces flat JSON Schema for missing UPS fields, build_order_data_from_form() for merging form data with defaults, and create_interactive_job() for creating single-row jobs.</done>
</task>

<task type="auto">
  <name>Task 2: Add interactive shipping tools to tools_v2.py and update system prompt</name>
  <files>src/orchestrator/agent/tools_v2.py, src/orchestrator/agent/system_prompt.py</files>
  <action>
**In `src/orchestrator/agent/tools_v2.py`**, add two new tools:

1. **`start_interactive_shipment` tool handler** (`async def start_interactive_shipment_tool(args, bridge)`):
   - Takes `args` with:
     - `command` (str, required): Original user command text
     - `extracted_data` (dict, optional): Partial shipping data the agent extracted from the NL command. Keys should be from the canonical set: `ship_to_name`, `ship_to_address1`, `ship_to_city`, `ship_to_state`, `ship_to_postal_code`, `weight`, `service_code`, etc.
   - Calls `generate_form_schema(extracted_data or {})` from interactive_shipping module
   - If schema has empty `properties` (all required fields provided):
     - Skip form, directly create job via `create_interactive_job()`, then run preview via `_run_batch_preview()`, emit `preview_ready`, return preview result (same pattern as `ship_command_pipeline_tool`)
   - If schema has properties (missing fields):
     - Emit SSE event via `_emit_event("elicitation_form", {"schema": schema, "command": command}, bridge=bridge)`
     - Return `_ok({"status": "elicitation_sent", "missing_fields": list(schema["required"]), "message": "Elicitation form sent to user. Wait for form submission before proceeding."})`
   - Uses `_bind_bridge` pattern for bridge injection

2. **`submit_interactive_form` tool handler** (`async def submit_interactive_form_tool(args, bridge)`):
   - Takes `args` with:
     - `form_data` (dict, required): Complete shipping data from submitted form
     - `command` (str, required): Original command for job name
   - Calls `create_interactive_job(form_data, command)` to create Job + single JobRow
   - Runs preview via `_run_batch_preview(job_id)` (same as batch_preview_tool)
   - Enriches preview rows (same pattern as batch_preview_tool)
   - Emits `preview_ready` event via `_emit_preview_ready()`
   - Returns slim LLM payload (same as batch_preview_tool)
   - On error, returns `_err()` with descriptive message
   - Uses `_bind_bridge` pattern for bridge injection

3. **Register both tools** in `get_all_tool_definitions()`:

   Add to the returned list:
   ```python
   {
       "name": "start_interactive_shipment",
       "description": (
           "Start an interactive single-shipment flow when user wants to ship "
           "a package without a data source file. Extracts available fields from "
           "the command and sends an elicitation form to collect missing fields. "
           "Use ONLY when user explicitly describes shipping a single package "
           "(e.g., 'ship a box to...', 'send a package to...')."
       ),
       "input_schema": {
           "type": "object",
           "properties": {
               "command": {
                   "type": "string",
                   "description": "Original user command text.",
               },
               "extracted_data": {
                   "type": "object",
                   "description": (
                       "Partial shipping data extracted from the command. "
                       "Use canonical keys: ship_to_name, ship_to_address1, "
                       "ship_to_city, ship_to_state, ship_to_postal_code, "
                       "weight, service_code."
                   ),
               },
           },
           "required": ["command"],
       },
       "handler": _bind_bridge(start_interactive_shipment_tool, bridge),
   },
   {
       "name": "submit_interactive_form",
       "description": (
           "Process a completed interactive shipping form. Creates a single-row "
           "job and generates preview. Called after user fills the elicitation form."
       ),
       "input_schema": {
           "type": "object",
           "properties": {
               "form_data": {
                   "type": "object",
                   "description": "Complete shipping data from the submitted form.",
               },
               "command": {
                   "type": "string",
                   "description": "Original user command for job naming.",
               },
           },
           "required": ["form_data", "command"],
       },
       "handler": _bind_bridge(submit_interactive_form_tool, bridge),
   },
   ```

**In `src/orchestrator/agent/system_prompt.py`**, update `build_system_prompt()`:

Add a new section AFTER the "## Workflow" section header, before "### Shipping Commands":

```
### Interactive Shipping (no data source required)

When the user wants to ship a single package without a data source file (e.g., "Ship a 5lb box to John Smith at 123 Main St, NY 10001"):

1. **Extract data**: Parse the command to identify any shipping fields mentioned (recipient name, address, weight, service, etc.)
2. **Call `start_interactive_shipment`**: Pass the command and extracted_data dict with canonical keys (ship_to_name, ship_to_address1, ship_to_city, ship_to_state, ship_to_postal_code, weight, service_code)
3. **Wait for form**: If fields are missing, an elicitation form is shown to the user. Do NOT call any other tools until the form is submitted.
4. **After form submission**: The system automatically creates a preview. Respond with one brief sentence asking the user to review the preview.

Important:
- This flow does NOT require a connected data source.
- Do NOT call get_source_info or fetch_rows for interactive shipments.
- Extract as many fields as possible from the user's command to minimize form fields.
- Use canonical field keys: ship_to_name, ship_to_address1, ship_to_city, ship_to_state, ship_to_postal_code, weight, service_code.
```

Also update the existing "No data source connected" message in the data source section. When `source_info is None`, change the message to:
```
No data source connected. The user can:
- Connect a CSV, Excel, or database source from the sidebar for batch shipping
- Use interactive mode to ship a single package without a data source (e.g., "Ship a 5lb box to John Smith at 123 Main St, NY 10001")
```
  </action>
  <verify>
Run: `python -c "
from src.orchestrator.agent.tools_v2 import get_all_tool_definitions
defs = get_all_tool_definitions()
names = [d['name'] for d in defs]
assert 'start_interactive_shipment' in names, f'Missing start_interactive_shipment, got: {names}'
assert 'submit_interactive_form' in names, f'Missing submit_interactive_form, got: {names}'
print(f'Tool count: {len(defs)}, all tools: {names}')
"` -- should show 13+ tools including both new ones.

Run: `python -c "
from src.orchestrator.agent.system_prompt import build_system_prompt
prompt = build_system_prompt(source_info=None)
assert 'interactive' in prompt.lower(), 'System prompt should mention interactive shipping'
assert 'start_interactive_shipment' in prompt, 'System prompt should mention the tool name'
print('System prompt OK, length:', len(prompt))
"` -- should confirm interactive shipping instructions present.
  </verify>
  <done>Two new tools (start_interactive_shipment, submit_interactive_form) registered in tools_v2.py. System prompt updated with interactive shipping workflow. Agent can detect interactive intent, extract fields, and emit elicitation_form SSE event. Total of 13+ tools available.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.services.interactive_shipping import generate_form_schema; print('Service OK')"` succeeds
2. `python -c "from src.orchestrator.agent.tools_v2 import get_all_tool_definitions; assert len(get_all_tool_definitions()) >= 13; print('Tools OK')"` succeeds
3. `python -c "from src.orchestrator.agent.system_prompt import build_system_prompt; p = build_system_prompt(); assert 'interactive' in p.lower(); print('Prompt OK')"` succeeds
4. Schema generation is deterministic: no LLM imports in interactive_shipping.py
5. Tools follow existing _ok/_err/_emit_event patterns from tools_v2.py
</verification>

<success_criteria>
- InteractiveShippingService deterministically generates flat JSON Schema for missing fields
- Two new tools exist in tools_v2.py following the established handler + registration pattern
- System prompt instructs agent on when/how to use interactive shipping tools
- Agent can call start_interactive_shipment which emits elicitation_form SSE event
- submit_interactive_form creates single-row job and runs preview through existing BatchEngine
- No new LLM calls introduced -- schema generation is pure Python
</success_criteria>

<output>
After completion, create `.planning/phases/08-interactive-shipping/08-01-SUMMARY.md`
</output>
