---
phase: 08-interactive-shipping
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/components/DynamicFormRenderer.tsx
  - frontend/src/components/CommandCenter.tsx
  - frontend/src/hooks/useAppState.tsx
  - frontend/src/types/api.ts
  - frontend/src/lib/api.ts
autonomous: true

must_haves:
  truths:
    - "User sees a dynamic form rendered inline in chat when system returns an elicitation response"
    - "Form renders correct input types: text for strings, number for weight, dropdown for service level"
    - "Pre-filled values from NL command appear in form fields as editable defaults"
    - "User can click 'Interactive Ship' button to start guided shipment creation without typing a command"
    - "User can accept (submit) or cancel the form per MCP Response Action model"
    - "After form submission, standard PreviewCard appears with single-row cost estimate"
    - "Command input is enabled even without a data source (for interactive commands)"
  artifacts:
    - path: "frontend/src/components/DynamicFormRenderer.tsx"
      provides: "Dynamic form component rendering flat JSON Schema"
      min_lines: 120
    - path: "frontend/src/components/CommandCenter.tsx"
      provides: "Updated with elicit action handler, Interactive Ship button, relaxed input gating"
      contains: "DynamicFormRenderer"
    - path: "frontend/src/hooks/useAppState.tsx"
      provides: "Extended ConversationMessage metadata for schema-based elicitation"
      contains: "formSchema"
    - path: "frontend/src/types/api.ts"
      provides: "Interactive shipping TypeScript types"
      contains: "ElicitationResponse"
    - path: "frontend/src/lib/api.ts"
      provides: "API client functions for interactive endpoints"
      contains: "startInteractiveShipment"
  key_links:
    - from: "frontend/src/components/CommandCenter.tsx"
      to: "frontend/src/components/DynamicFormRenderer.tsx"
      via: "import and render when action is 'elicit'"
      pattern: "DynamicFormRenderer"
    - from: "frontend/src/lib/api.ts"
      to: "/api/v1/interactive/start"
      via: "fetch call to start endpoint"
      pattern: "interactive/start"
    - from: "frontend/src/lib/api.ts"
      to: "/api/v1/interactive/submit"
      via: "fetch call to submit endpoint"
      pattern: "interactive/submit"
---

<objective>
Build the frontend components for interactive shipping: the DynamicFormRenderer, CommandCenter integration, API client functions, and TypeScript types.

Purpose: This plan delivers the user-facing interactive shipping experience. Users see inline forms in the chat thread, can click an "Interactive Ship" button to start without typing, and the standard preview/execute flow takes over after form submission. The form renderer reads flat JSON Schema and generates field-type-aware inputs.

Output: New `DynamicFormRenderer.tsx` component, updated `CommandCenter.tsx` with elicit handling and Interactive Ship button, extended types and API client.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-interactive-shipping/08-RESEARCH.md
@.planning/phases/08-interactive-shipping/08-01-SUMMARY.md

@frontend/src/components/CommandCenter.tsx
@frontend/src/hooks/useAppState.tsx
@frontend/src/types/api.ts
@frontend/src/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TypeScript types and API client functions for interactive shipping</name>
  <files>frontend/src/types/api.ts, frontend/src/lib/api.ts</files>
  <action>
**In `frontend/src/types/api.ts`, add at the end of the file:**

```typescript
// === Interactive Shipping Types ===

/** JSON Schema property definition for dynamic form rendering. */
export interface SchemaProperty {
  type: string;
  title?: string;
  description?: string;
  default?: string | number | boolean;
  minimum?: number;
  maximum?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  format?: string;
  enum?: string[];
  oneOf?: Array<{ const: string; title: string }>;
}

/** Flat JSON Schema for dynamic form generation (MCP-compliant). */
export interface FormSchema {
  type: "object";
  properties: Record<string, SchemaProperty>;
  required?: string[];
}

/** Response when the system needs elicitation (form input) from the user. */
export interface ElicitationResponse {
  action: "elicit";
  message: string;
  schema: FormSchema;
  initial_data: Record<string, unknown>;
  job_id?: string | null;
}

/** Request for submitting interactive shipment form data. */
export interface InteractiveShipmentRequest {
  form_data: Record<string, unknown>;
  job_id?: string | null;
}
```

**In `frontend/src/lib/api.ts`, add at the end of the file (before any closing comments):**

Add import for the new types at the top imports section:
```typescript
import type {
  ElicitationResponse,
  InteractiveShipmentRequest,
} from '@/types/api';
```
(Add to the existing import block from '@/types/api')

Then add the functions:

```typescript
// === Interactive Shipping API ===

/**
 * Start an interactive shipping flow.
 *
 * For NL commands: extracts shipping fields and returns form for missing ones.
 * For button mode: returns full form with all fields.
 *
 * @param command - Optional NL command (omit for button-initiated flow).
 * @returns Elicitation response with JSON Schema for dynamic form rendering.
 */
export async function startInteractiveShipment(
  command?: string
): Promise<ElicitationResponse> {
  const body: Record<string, unknown> = {};
  if (command) body.command = command;
  else body.command = '';

  const params = command ? '' : '?mode=button';

  const response = await fetch(`${API_BASE}/interactive/start${params}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  return parseResponse<ElicitationResponse>(response);
}

/**
 * Submit filled interactive shipment form data.
 *
 * Creates a single-row job from the form data, rates it via UPS,
 * and returns a standard batch preview response.
 *
 * @param formData - User-filled form data matching the elicitation schema.
 * @returns Batch preview with single-row cost estimate.
 */
export async function submitInteractiveShipment(
  formData: Record<string, unknown>
): Promise<{ job_id: string; preview: BatchPreview }> {
  const response = await fetch(`${API_BASE}/interactive/submit`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ form_data: formData }),
  });
  return parseResponse<{ job_id: string; preview: BatchPreview }>(response);
}
```
  </action>
  <verify>
    Run: `cd /Users/matthewhans/Desktop/Programming/ShipAgent/frontend && npx tsc --noEmit 2>&1 | head -20` - No type errors.
  </verify>
  <done>
    - SchemaProperty, FormSchema, ElicitationResponse, InteractiveShipmentRequest types defined
    - startInteractiveShipment() and submitInteractiveShipment() API functions implemented
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DynamicFormRenderer component</name>
  <files>frontend/src/components/DynamicFormRenderer.tsx</files>
  <action>
Create `frontend/src/components/DynamicFormRenderer.tsx`:

This component renders a flat JSON Schema as an inline form in the chat thread. It follows the existing card pattern (same styling as PreviewCard).

**Props interface:**
```typescript
interface DynamicFormRendererProps {
  schema: FormSchema;       // From ElicitationResponse
  message: string;          // Human-readable prompt
  initialData?: Record<string, unknown>;  // Pre-filled values
  onSubmit: (data: Record<string, unknown>) => void;
  onCancel: () => void;
  isSubmitting?: boolean;
}
```

**State management:**
- `formData`: Record<string, unknown> initialized from schema property defaults merged with initialData
- `errors`: Record<string, string> for client-side validation messages
- Required fields tracked from `schema.required`

**Field rendering logic (renderField function):**
For each property in `schema.properties`, render based on type:

1. **oneOf array present** -> `<select>` dropdown with option elements from oneOf entries
   - Value: `opt.const`, Display: `opt.title`
   - Include empty "Select..." option
   - CSS: `w-full px-3 py-2 bg-slate-800/70 border border-slate-700 rounded-md text-sm text-slate-200`

2. **enum array present** -> `<select>` dropdown
   - Same styling as oneOf

3. **type === 'number' or 'integer'** -> `<input type="number">`
   - Set `min`, `max`, `step` from schema constraints
   - step: 0.1 for number, 1 for integer
   - Parse value as Number on change

4. **type === 'boolean'** -> `<input type="checkbox">` with label
   - Don't show separate label above (label is inline)

5. **Default (type === 'string')** -> `<input type="text">`
   - Set `minLength`, `maxLength`, `pattern` from schema
   - Set `placeholder` from property description
   - Format-specific: use `type="email"` if format is "email"

**Label rendering:**
Each field (except boolean) gets a label:
```tsx
<label className="block text-xs font-medium text-slate-300 mb-1">
  {prop.title || key}
  {required.has(key) && <span className="text-red-400 ml-1">*</span>}
</label>
```

**Form layout:**
- Wrap in `<form>` with `onSubmit` handler
- Use `card-premium` outer div matching PreviewCard style
- Header: "Interactive Shipment" title
- Message paragraph below header
- Fields in a `space-y-3` container
- Two-column grid for related fields (city+state, length+width+height) using:
  - Group city/state/zip in a 3-column grid: `grid grid-cols-3 gap-2`
  - Group dimensions in a 3-column grid if all three present
  - All other fields full width

**Action buttons (sticky at bottom):**
```tsx
<div className="flex gap-3 pt-2">
  <button type="button" onClick={onCancel} disabled={isSubmitting}
    className="flex-1 btn-secondary py-2.5">
    Cancel
  </button>
  <button type="submit" disabled={isSubmitting}
    className="flex-1 btn-primary py-2.5">
    {isSubmitting ? 'Creating Shipment...' : 'Create Shipment'}
  </button>
</div>
```

**Client-side validation on submit:**
Before calling onSubmit:
1. Check all required fields have non-empty values
2. Check number fields are within min/max bounds
3. If errors exist, set `errors` state and don't submit
4. Show error messages below each invalid field in red text

**Styling notes:**
- Use existing CSS classes: `card-premium`, `btn-primary`, `btn-secondary`, `border-gradient`, `animate-scale-in`
- Input styling: `w-full px-3 py-2 bg-slate-800/70 border border-slate-700 rounded-md text-sm text-slate-200 placeholder:text-slate-500 focus:outline-none focus:border-primary/50 focus:ring-1 focus:ring-primary/25`
- This matches the existing refinement input style in PreviewCard
- No external dependencies (no react-jsonschema-form)

Export as named export: `export function DynamicFormRenderer(...)`
  </action>
  <verify>
    Run: `cd /Users/matthewhans/Desktop/Programming/ShipAgent/frontend && npx tsc --noEmit 2>&1 | head -20` - No type errors.
  </verify>
  <done>
    - DynamicFormRenderer renders text, number, select, and checkbox inputs from flat JSON Schema
    - Pre-filled values appear as editable defaults
    - Client-side validation for required fields and numeric bounds
    - Cancel and Submit buttons with loading state
    - Styled consistently with existing card-premium pattern
    - No external form library dependencies
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate DynamicFormRenderer into CommandCenter + add Interactive Ship button</name>
  <files>frontend/src/components/CommandCenter.tsx, frontend/src/hooks/useAppState.tsx</files>
  <action>
**In `frontend/src/hooks/useAppState.tsx`:**

Extend the `ConversationMessage.metadata.elicitation` type to support JSON Schema mode:

Change the existing `elicitation` field in metadata from:
```typescript
elicitation?: {
  questions: Array<{
    id: string;
    question: string;
    options: string[];
  }>;
};
```
to:
```typescript
elicitation?: {
  // Legacy batch clarification mode
  questions?: Array<{
    id: string;
    question: string;
    options: string[];
  }>;
  // Interactive shipping JSON Schema mode
  formSchema?: {
    type: "object";
    properties: Record<string, unknown>;
    required?: string[];
  };
  formMessage?: string;
  initialData?: Record<string, unknown>;
};
```

This is backward compatible -- existing `questions` field becomes optional.

**In `frontend/src/components/CommandCenter.tsx`:**

1. **Import DynamicFormRenderer and API functions:**
   ```typescript
   import { DynamicFormRenderer } from '@/components/DynamicFormRenderer';
   import { startInteractiveShipment, submitInteractiveShipment } from '@/lib/api';
   import type { FormSchema } from '@/types/api';
   ```

2. **Add state for interactive flow:**
   In the main `CommandCenter` component, add:
   ```typescript
   const [interactiveForm, setInteractiveForm] = React.useState<{
     schema: FormSchema;
     message: string;
     initialData: Record<string, unknown>;
   } | null>(null);
   const [isSubmittingForm, setIsSubmittingForm] = React.useState(false);
   ```

3. **Modify input gating to allow interactive commands without data source:**

   Currently the input is disabled when `!hasDataSource`. Change this so the input is always enabled (the backend will determine if the command is interactive or batch):

   In the input element:
   - Change `disabled={!hasDataSource || isProcessing || !!preview || !!executingJobId}` to:
     `disabled={isProcessing || !!preview || !!executingJobId || !!interactiveForm}`
   - Change the placeholder logic:
     ```typescript
     placeholder={
       !hasDataSource
         ? 'Type a shipping command or click Interactive Ship...'
         : 'Enter a shipping command...'
     }
     ```
   - Update the submit button disabled condition similarly (remove `!hasDataSource`)

4. **Modify handleSubmit to detect interactive commands:**

   In `handleSubmit`, after adding the user message and before the try block, add a check:

   ```typescript
   // Check if this might be an interactive command (no data source connected)
   if (!hasDataSource) {
     try {
       const elicitResponse = await startInteractiveShipment(command);
       setInteractiveForm({
         schema: elicitResponse.schema,
         message: elicitResponse.message,
         initialData: elicitResponse.initial_data,
       });
       addMessage({
         role: 'system',
         content: elicitResponse.message,
         metadata: {
           action: 'elicit',
           elicitation: {
             formSchema: elicitResponse.schema,
             formMessage: elicitResponse.message,
             initialData: elicitResponse.initial_data,
           },
         },
       });
     } catch (err) {
       addMessage({
         role: 'system',
         content: `Error: ${err instanceof Error ? err.message : 'Failed to process command'}`,
         metadata: { action: 'error' },
       });
     } finally {
       setIsProcessing(false);
     }
     return;
   }
   // ... existing batch flow continues for data source commands
   ```

5. **Add Interactive Ship button in WelcomeMessage:**

   In the `WelcomeMessage` component, add a button AFTER the workflow steps and BEFORE examples, visible when NOT connected:

   ```tsx
   {/* Interactive Ship button - available without data source */}
   <button
     onClick={() => onInteractiveShip?.()}
     className="btn-primary py-2.5 px-6 flex items-center gap-2 mx-auto mb-6"
   >
     <PackageIcon className="w-4 h-4" />
     <span>Interactive Ship</span>
   </button>
   <p className="text-xs text-slate-500 -mt-4 mb-6">Create a single shipment without a data source</p>
   ```

   Update `WelcomeMessage` props to accept `onInteractiveShip?: () => void`. Also add it to the connected view as an additional action.

   Also add a small "Interactive Ship" button in the input area (next to the Send button) that is always visible:
   ```tsx
   <button
     onClick={handleInteractiveShipClick}
     disabled={isProcessing || !!preview || !!executingJobId || !!interactiveForm}
     title="Create a single shipment"
     className={cn(
       'px-3 py-2 rounded-md border border-slate-700 text-xs text-slate-400 hover:text-primary hover:border-primary/50 transition-colors',
       (isProcessing || !!preview || !!executingJobId || !!interactiveForm) && 'opacity-50 cursor-not-allowed'
     )}
   >
     <PackageIcon className="w-4 h-4" />
   </button>
   ```

6. **Add handleInteractiveShipClick handler:**
   ```typescript
   const handleInteractiveShipClick = async () => {
     if (isProcessing || preview || executingJobId || interactiveForm) return;
     setIsProcessing(true);

     addMessage({ role: 'user', content: 'Start interactive shipment' });

     try {
       const elicitResponse = await startInteractiveShipment();
       setInteractiveForm({
         schema: elicitResponse.schema,
         message: elicitResponse.message,
         initialData: elicitResponse.initial_data,
       });
       addMessage({
         role: 'system',
         content: elicitResponse.message,
         metadata: {
           action: 'elicit',
           elicitation: {
             formSchema: elicitResponse.schema,
             formMessage: elicitResponse.message,
             initialData: elicitResponse.initial_data,
           },
         },
       });
     } catch (err) {
       addMessage({
         role: 'system',
         content: `Error: ${err instanceof Error ? err.message : 'Failed to start interactive shipment'}`,
         metadata: { action: 'error' },
       });
     } finally {
       setIsProcessing(false);
     }
   };
   ```

7. **Add form submission handler:**
   ```typescript
   const handleFormSubmit = async (formData: Record<string, unknown>) => {
     if (isSubmittingForm) return;
     setIsSubmittingForm(true);

     try {
       const result = await submitInteractiveShipment(formData);
       setInteractiveForm(null);
       setCurrentJobId(result.job_id);
       setPreview(result.preview);

       addMessage({
         role: 'system',
         content: `Shipment ready. Estimated cost: ${formatCurrency(result.preview.total_estimated_cost_cents)}.\n\nReview the preview below and confirm to proceed.`,
         metadata: {
           jobId: result.job_id,
           action: 'preview',
           preview: {
             rowCount: result.preview.total_rows,
             estimatedCost: result.preview.total_estimated_cost_cents,
             warnings: result.preview.rows_with_warnings,
           },
         },
       });
     } catch (err) {
       addMessage({
         role: 'system',
         content: `Error: ${err instanceof Error ? err.message : 'Failed to create shipment'}`,
         metadata: { action: 'error' },
       });
     } finally {
       setIsSubmittingForm(false);
     }
   };

   const handleFormCancel = () => {
     setInteractiveForm(null);
     addMessage({
       role: 'system',
       content: 'Interactive shipment cancelled.',
     });
   };
   ```

8. **Render DynamicFormRenderer in the messages area:**

   After the preview card section and before the progress display, add:
   ```tsx
   {/* Interactive shipping form */}
   {interactiveForm && !preview && !executingJobId && (
     <div className="pl-11">
       <DynamicFormRenderer
         schema={interactiveForm.schema}
         message={interactiveForm.message}
         initialData={interactiveForm.initialData}
         onSubmit={handleFormSubmit}
         onCancel={handleFormCancel}
         isSubmitting={isSubmittingForm}
       />
     </div>
   )}
   ```

9. **Update auto-scroll dependencies:**
   Add `interactiveForm` to the useEffect dependency array for auto-scrolling:
   ```typescript
   React.useEffect(() => {
     messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
   }, [conversation, preview, executingJobId, activeJob, interactiveForm]);
   ```

IMPORTANT NOTES:
- The `hasDataSource` check is RELAXED for the input field but the EXISTING batch flow still checks for data sources. Only the interactive path bypasses the data source requirement.
- After form submission returns a preview, the EXISTING PreviewCard -> confirm -> execute flow takes over. No changes needed to the confirm/execute/complete path.
- The `PackageIcon` SVG component already exists in CommandCenter.tsx -- reuse it.
  </action>
  <verify>
    Run: `cd /Users/matthewhans/Desktop/Programming/ShipAgent/frontend && npx tsc --noEmit 2>&1 | head -20` - No type errors.
    Run: `cd /Users/matthewhans/Desktop/Programming/ShipAgent/frontend && npm run build 2>&1 | tail -5` - Build succeeds.
  </verify>
  <done>
    - DynamicFormRenderer appears inline in chat when elicit action received
    - "Interactive Ship" button visible in welcome message and input area
    - Command input enabled without data source for interactive commands
    - Form submission flows into standard PreviewCard -> confirm -> execute pipeline
    - ConversationMessage metadata supports formSchema for elicitation
    - All existing batch command flow unchanged
    - TypeScript compiles, build succeeds
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx tsc --noEmit` - TypeScript compilation clean
2. `cd frontend && npm run build` - Production build succeeds
3. Visual check: Interactive Ship button visible on welcome screen
4. Visual check: Form renders inline in chat with correct input types
5. Visual check: Form pre-fills values from NL command
</verification>

<success_criteria>
- DynamicFormRenderer component renders all field types correctly from JSON Schema
- "Interactive Ship" button starts guided flow without NL command
- NL commands without data source route to interactive flow
- Form submission produces standard preview (existing flow takes over)
- Cancel dismisses form and restores input
- Input enabled even without data source
- No regressions in existing batch command flow
</success_criteria>

<output>
After completion, create `.planning/phases/08-interactive-shipping/08-03-SUMMARY.md`
</output>
